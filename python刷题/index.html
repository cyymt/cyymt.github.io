
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.3">
    
    
      
        <title>python刷题 - 个人笔记</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.1655a90d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.7fa14f5b.min.css">
        
          
          
          <meta name="theme-color" content="#009485">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="teal" data-md-color-accent="pink">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="个人笔记" class="md-header__button md-logo" aria-label="个人笔记">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            个人笔记
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              python刷题
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="个人笔记" class="md-nav__button md-logo" aria-label="个人笔记">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    个人笔记
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      <label class="md-nav__link" for="__nav_1">
        一、计算机视觉专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="一、计算机视觉专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          一、计算机视觉专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        目标检测论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../OCR%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        OCR方向论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E8%84%B8%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        人脸方向论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        图像识别论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        深度学习基础
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      <label class="md-nav__link" for="__nav_2">
        二、AI代码专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="二、AI代码专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          二、AI代码专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../PyTorch%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B/" class="md-nav__link">
        PyTorch快速教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../PaddlePaddle%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B/" class="md-nav__link">
        PaddlePaddle快速教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../caffe%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" class="md-nav__link">
        Caffe快速教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../onnx%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" class="md-nav__link">
        ONNX简明教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81/" class="md-nav__link">
        深度学习工具代码
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../pandas%E3%80%81matplotlib%E7%AE%80%E6%B4%81%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        PD+PLT简洁笔记
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      <label class="md-nav__link" for="__nav_3">
        三、常用工具专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="三、常用工具专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          三、常用工具专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%87%8F%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        量化工具使用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/" class="md-nav__link">
        实用工具教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/" class="md-nav__link">
        学习网站收集
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E5%BA%93%28albumentations%2BAugmentor%29/" class="md-nav__link">
        图像增强库
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      <label class="md-nav__link" for="__nav_4">
        四、编程语言专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="四、编程语言专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          四、编程语言专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../c%2B%2B%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" class="md-nav__link">
        c++简明教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../vim_cmake_git/" class="md-nav__link">
        vim_git_cmake
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          python刷题
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        python刷题
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    字符串
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list-" class="md-nav__link">
    List-数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数组字符串题目
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    双端队列(具有队列和栈的性质)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    哈希表(散列表)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dict-set" class="md-nav__link">
    dict + set
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    递归
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    查找+排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    树与二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    堆排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    优先级队列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#on" class="md-nav__link">
    二叉查找树(效率最高:O(N))
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    图
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../java%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8Band%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/" class="md-nav__link">
        java简明教程and安卓开发
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    字符串
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list-" class="md-nav__link">
    List-数组
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    数组字符串题目
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    链表
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    双端队列(具有队列和栈的性质)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    哈希表(散列表)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dict-set" class="md-nav__link">
    dict + set
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    递归
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    查找+排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    树与二叉树
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    堆排序
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    优先级队列
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#on" class="md-nav__link">
    二叉查找树(效率最高:O(N))
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    图
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>python刷题</h1>
                
                <p><a href="https://pegasuswang.github.io/python_data_structures_and_algorithms/">数据结构与算法</a></p>
<h3 id="_1">字符串<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p><strong>测试函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#s以字符串t结尾，区分大小写</span>
<span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#s以字符串t开头，区分大小写</span>
<span class="n">s</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="c1">#s只包含字符串或数字</span>
<span class="n">s</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="c1">#s只包含字符串</span>
<span class="n">s</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="c1">#s只包含数字字符</span>
<span class="n">s</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">()</span> <span class="c1">#s是否合法标识符</span>
<span class="n">s</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span> <span class="c1">#s是否只包含小写字符</span>
<span class="n">s</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span> <span class="c1">#s只包含数字</span>
<span class="n">s</span><span class="o">.</span><span class="n">isprintable</span><span class="p">()</span> <span class="c1">#s是否只包含可打印字符</span>
<span class="n">s</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="c1">#s只包含空白字符</span>
<span class="n">s</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span> <span class="c1">#s是否符合头衔大小写</span>
<span class="n">s</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span> <span class="c1">#s是否只包含大写字母</span>
<span class="c1">#s in t t是否包含s</span>
</code></pre></div>
<p><strong>改变字符串大小写</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="c1">#将s[0]变成大写</span>
<span class="n">s</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="c1">#将字母全部改成小写</span>
<span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="c1">#将字母全部改成大写</span>
<span class="n">s</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span> <span class="c1">#交换大小写</span>
<span class="n">s</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="c1">#将字符串改成符合头衔大小写</span>
</code></pre></div>
<p><strong>搜索函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#如果没有找到子字符串t，返回-1，否则返回t在s中的起始位置</span>
<span class="n">s</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#如果没有找到子字符串t，返回-1，否则返回t在s中的最后一个的位置</span>
<span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#如果没有找到子字符串t，返回ValueError异常，否则返回t在s中的起始位置</span>
<span class="n">s</span><span class="o">.</span><span class="n">rindex</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#如果没有找到子字符串t，返回ValueError异常，否则返回t在s中的最后一个的位置</span>
</code></pre></div>
<p><strong>设置格式函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">ch</span><span class="p">)</span> <span class="c1">#包含n个字符串，其中s位于中间，两边使用ch填充</span>
<span class="n">s</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">ch</span><span class="p">)</span> <span class="c1">#包含n个字符串，其中s位于右边，左边使用ch填充</span>
<span class="n">s</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">ch</span><span class="p">)</span> <span class="c1">#包含n个字符串，其中s位于左边，右边使用ch填充</span>
<span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span><span class="n">ch2</span><span class="p">)</span> <span class="c1">#s中包含{0}{1}的位置被ch1、ch2填充</span>
</code></pre></div>
<p><strong>字符串剥除函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="c1">#去除字符串s中开头和结尾的ch字符串</span>
<span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="c1">#去除字符串s中开头的ch字符串</span>
<span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="c1">#去除字符串s中结尾的ch字符串</span>
</code></pre></div>
<p><strong>字符串拆分函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;ch&#39;</span><span class="p">)</span> <span class="c1">#将字符串s按照ch字符串分成三个部分，从左到右的顺序</span>
<span class="n">s</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;ch&#39;</span><span class="p">)</span> <span class="c1">#将字符串s按照ch字符串分成三个部分，从右到左的顺序</span>
<span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;ch&#39;</span><span class="p">)</span> <span class="c1">#以ch为分隔符，将s进行分割，并返回分割后的列表</span>
<span class="n">s</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;ch&#39;</span><span class="p">)</span> <span class="c1">#以ch为分隔符，将s进行分割，并返回分割后的列表,从s的右端开始搜索ch</span>
</code></pre></div>
<p><strong>字符串替换</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">)</span> <span class="c1">#将字符串s中的old子字符串全部替换成new</span>
<span class="n">s</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1">#将字符串s中的每个制表符替换成n个空格</span>
</code></pre></div>
<p><strong>其他函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="s1">&#39;sep&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="c1"># 以sep作为分隔符，将seq所有的元素合并成一个新的字符串</span>
<span class="n">s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;ch&#39;</span><span class="p">)</span> <span class="c1">#统计字符串s中ch的出现次数</span>
<span class="n">s</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="s1">&#39;old&#39;</span><span class="p">,</span><span class="s1">&#39;new&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">t</span> <span class="c1">#创建一个转换表t，用于将s中的old替换成new</span>
<span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#按照转换表t将s中的字符进行替换</span>
</code></pre></div>
<h3 id="list-">List-数组<a class="headerlink" href="#list-" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># 在列表末尾添加新的对象</span>
<span class="nb">list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="c1"># 扩展列表，在列表末尾一次性追加另一个列表中的多个值（相当于把list1的元素复制到了list）</span>
<span class="nb">list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="c1"># 移出列表中的索引是index的元素，（默认最后一个元素）</span>
<span class="nb">list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># 移除列表中某个值的第一个匹配项（只会移出第一个）</span>
<span class="nb">list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># 从列表中找出某个值第一个匹配项的索引位置</span>
<span class="nb">list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">value</span><span class="p">)</span> <span class="c1"># 将对象插入列表的第index个位置</span>
<span class="nb">list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># 从小到大排序</span>
<span class="nb">list</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="c1"># 反向列表中的元素</span>
<span class="nb">list</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># 统计某个元素在列表中出现的次数</span>
<span class="nb">list</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># 复制一个副本，原值和新复制的变量互不影响</span>
<span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span><span class="err">、</span><span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span><span class="err">、</span><span class="nb">min</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</code></pre></div>
<h3 id="_2">数组字符串题目<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p><strong>1.大数相加</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">time</span>
<span class="n">L1</span> <span class="o">=</span> <span class="s2">&quot;2649821731631836529481632803462831616487712734074314936141303241873417434716340124362304724324324324324323412121323164329751831&quot;</span>
<span class="n">L2</span> <span class="o">=</span> <span class="s2">&quot;1232141045091731748365195814509145981509438583247509149821493213241431431319999999999999999999999999999999999999999999999999341344779&quot;</span>

<span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">L2</span><span class="p">))</span>
<span class="c1"># str.zfill(width) 指定字符串的长度。原字符串右对齐，前面填充0。</span>
<span class="n">l1</span> <span class="o">=</span> <span class="n">L1</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span>
<span class="n">l2</span> <span class="o">=</span> <span class="n">L2</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span>

<span class="n">a1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span>
<span class="n">a3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">index_sum</span> <span class="o">=</span> <span class="n">a3</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">a2</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">less</span> <span class="o">=</span> <span class="n">index_sum</span> <span class="o">-</span> <span class="mi">10</span>
    <span class="n">a3</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_sum</span> <span class="o">%</span> <span class="mi">10</span>
    <span class="n">a3</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">less</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

<span class="k">if</span><span class="p">(</span><span class="n">a3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">a3</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">a33</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a33</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;耗时</span><span class="si">{0}</span><span class="s1">ms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">))</span>
</code></pre></div>
<p><strong>2.寻找数组的中心索引</strong></p>
<p><img alt="image-20200127170630724" src="../assets/image-20200127170630724.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pivotIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">total_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">left_sums</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">left_sums</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_sums</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">left_sums</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="o">==</span><span class="n">total_sum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">index</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p><strong>3.至少是其他数字两倍的最大数</strong></p>
<p><img alt="image-20200127171453006" src="../assets/image-20200127171453006.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dominantIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">max_num</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_num</span><span class="p">)</span>
        <span class="n">nums</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">max_num</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">max_num</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<p><strong>4.加一</strong></p>
<p><img alt="image-20200127172528547" src="../assets/image-20200127172528547.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">plusOne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">digits</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
          <span class="c1"># 倘若每一步都是重复的操作，建议使用递归</span>
            <span class="n">digits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plusOne</span><span class="p">(</span><span class="n">digits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">digits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">digits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">digits</span>
</code></pre></div>
<h3 id="_3">链表<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p><strong>单链表</strong></p>
<p><img alt="image-20200128111905169" src="../assets/image-20200128111905169.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span><span class="nb">next</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Full&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">appendLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Full&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">tempNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">tempNode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">iterNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tempNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>
        <span class="k">while</span> <span class="n">tempNode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tempNode</span>
            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">next</span>
        <span class="k">yield</span> <span class="n">tempNode</span> <span class="c1"># 这个返回的是tailNode</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterNode</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterNode</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">==</span><span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">index</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="n">preNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">curNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>
        <span class="k">for</span> <span class="n">curNode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterNode</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">curNode</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">preNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">curNode</span><span class="o">.</span><span class="n">next</span>
                <span class="k">if</span> <span class="n">curNode</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">taillNode</span> <span class="o">=</span> <span class="n">preNode</span>
                <span class="k">del</span> <span class="n">curNode</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preNode</span> <span class="o">=</span> <span class="n">curNode</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">popLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This LinkedList is empty!&quot;</span><span class="p">)</span>
        <span class="n">tempNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">next</span>
        <span class="n">resultValue</span> <span class="o">=</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">value</span>
        <span class="k">del</span> <span class="n">tempNode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">resultValue</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterNode</span><span class="p">():</span>
            <span class="k">del</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p><strong>循环双链表</strong></p>
<p><img alt="  " src="../assets/image-20200128134039403.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span><span class="n">prev</span><span class="p">,</span><span class="nb">next</span>

<span class="k">class</span> <span class="nc">CircleDoubleLinkedList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">prev</span><span class="p">,</span><span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">,</span><span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span> <span class="nf">headNone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>

    <span class="k">def</span> <span class="nf">tailNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">prev</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Full&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">tailNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tailNode</span><span class="p">()</span>
        <span class="n">tailNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tailNode</span>
        <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">appendLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Full&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span> <span class="c1"># empty</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">headNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>
            <span class="n">node</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
            <span class="n">headNode</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">headNode</span>
            <span class="n">headNode</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This node is not deleted!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>
            <span class="n">node</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">prev</span>
            <span class="k">del</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">iterNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Empty&quot;</span><span class="p">)</span>
        <span class="n">tempNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">next</span>
        <span class="k">while</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tempNode</span>
            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">next</span>
        <span class="k">yield</span> <span class="n">tempNode</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterNode</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">iterNodeReverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">prev</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">tempNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">prev</span>
        <span class="k">while</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tempNode</span>
            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">tempNode</span><span class="o">.</span><span class="n">prev</span>
        <span class="k">yield</span> <span class="n">tempNode</span>
</code></pre></div>
<p><strong>快慢指针</strong></p>
<p>快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动n(一般n=2)，慢指针每次向前移动1次。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">LinkNode</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">val</span><span class="p">,</span><span class="kc">None</span>

<span class="c1"># 1、判断单链表是否是循环链表,类似围着操场跑步，用快慢指针，跑的快的总会赶上跑的慢的</span>
<span class="k">class</span> <span class="nc">JudgeCircle</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">head</span><span class="p">):</span>
      <span class="n">fast</span><span class="p">,</span><span class="n">low</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span><span class="n">head</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
          <span class="n">fast</span> <span class="o">=</span>  <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
          <span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="o">.</span><span class="n">next</span>
          <span class="k">if</span> <span class="n">low</span><span class="o">==</span><span class="n">fast</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
      <span class="k">return</span> <span class="kc">False</span>
<span class="c1"># 2、寻找有序链表的中位数:快指针的移动速度是慢指针移动速度的2倍，因此当快指针到达链表尾时，慢指针到达中点。</span>
<span class="c1"># 注意:快指针到达尾部分奇偶，例如fast.next==None,fast.next.next==None</span>
<span class="k">class</span> <span class="nc">FindMiddle</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">findMid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">head</span><span class="p">):</span>
        <span class="n">fast</span><span class="p">,</span><span class="n">low</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span><span class="n">head</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">low</span><span class="o">.</span><span class="n">val</span>
          <span class="k">elif</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或（上中位数+下中位数）的一半。</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">low</span><span class="o">.</span><span class="n">val</span><span class="o">+</span><span class="n">low</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">val</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span>  <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="o">.</span><span class="n">next</span>
<span class="c1"># 3、删除倒数第n个节点,，并且返回链表的头结点:使用前后指针。前指针先走n步，然后前、后指针同时走，当前指针走到节点尾时，后指针刚好走到要删除的节点。</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="n">tempNode</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">fast</span><span class="p">,</span><span class="n">low</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span><span class="n">head</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
                <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">while</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="o">.</span><span class="n">next</span>
        <span class="n">low</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">low</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">tempNode</span>
<span class="c1"># 4、不止链表中可以使用，list中也可以，只不过是用索引，结束条件是&lt;len(nums),删除排序数组中的重复项,返回移除后数组的新长度.例如:nums = [0,0,1,1,1,2,2,3,3,4]---&gt; [0,1,2,3,4]</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">low</span><span class="p">,</span><span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">fast</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">fast</span><span class="p">]:</span>
                <span class="n">nums</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">fast</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">low</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">fast</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</code></pre></div>
<p>**LRU缓存机制：**首先淘汰**最长时间未被使用**的</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 如何优化斐波那契算法:下面是使用递归的，递归意味着有很多重复的</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>普通优化:添加装饰器，把重复的部分记录下来直接拿来用，无需做第二次计算</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span> <span class="c1"># 装饰器时尽量加上 </span>
<span class="c1"># 原因:https://www.cnblogs.com/wangtaobiu/p/10614451.html</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 用于收集已经计算过的部分</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># 加上wraps装饰器,保证原函数在执行时不会发生异常</span>
    <span class="k">def</span> <span class="nf">collect_repeat</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">collect_repeat</span>
<span class="c1"># 不加装饰器耗时:5.364307165145874ms</span>
<span class="c1"># 加了装饰器耗时:0.0002818107604980469ms</span>
<span class="nd">@wrapper</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">35</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total time:</span><span class="si">{</span><span class="n">total_time</span><span class="si">}</span><span class="s2">ms&quot;</span><span class="p">)</span>
</code></pre></div>
<p><strong>内存有限怎么办</strong>？</p>
<blockquote>
<p>问题来了，假如空间有限怎么办，我们不可能一直向缓存塞东西，当缓存达到一定个数之后，我们需要一种策略踢出一些元素，用来给新的元素腾出空间。</p>
<p><strong>一般缓存失效策略有</strong></p>
<ul>
<li>LRU(Least-Recently-Used): 替换掉最近请求最少的对象，<strong>实际中使用最广</strong>。cpu缓存淘汰和虚拟内存效果好，web应用欠佳</li>
<li>LFU(Least-Frequently-Used): 缓存污染问题(一个先前流行的缓存对象会在缓存中驻留很长时间)</li>
<li>First in First out(FIFO)</li>
<li>Random Cache: 随机选一个删除</li>
</ul>
<p>LRU 是常用的一个，要想实现一个 LRU，我们需要一种方式能够记录访问的顺序，并且每次访问之后我们要把最新使用到的元素放到最后（表示最新访问）。当容量满了以后，我们踢出最早访问的元素。假如用一个链表来表示的话：[1] -&gt; [2] -&gt; [3]。假设最后边是最后访问的，当访问到一个元素以后，我们把它放到最后。当容量满了，我们踢出第一个元素就行了。</p>
<ul>
<li>
<p>一开始的想法可能是用一个链表来记录访问顺序，但是单链表有个问题就是如果访问了中间一个元素，我们需要拿掉它并且放到链表尾部。而单链表无法在O(1)的时间内删除一个节点（必须要先搜索到它）。</p>
</li>
<li>
<p>但是双端链表可以，因为一个节点记录了它的前后节点，只需要把要删除的节点的前后节点链接起来就行了。</p>
</li>
<li>还有个问题是如何把删除后的节点放到链表尾部，如果是循环双端链表就可以啦，我们有个 root 节点链接了首位节点，只需要让 root 的前一个指向这个被删除节点，然后让之前的最后一个节点也指向它就行了。使用了循环双端链表之后，我们的操作就都是 O(1) 的了。</li>
</ul>
<p><strong>这也就是使用一个 dict 和一个 循环双端链表 实现LRU 的思路。</strong></p>
<p>不过一般我们使用内置的 OrderedDict(原理和这个类似)就好了，要实现一个循环双端链表是一个不简单的事情，因为链表操作很容易出错。</p>
<p>补充：其实 <strong>lru 有个缺点就是额外的链表比较占用空间</strong>，如果你感兴趣的话可以看看 redis 如何实现的 lru 算法。</p>
<p>补充2:OrderedDict</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1"># 使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用OrderedDict，Key会按照插入的顺序排列，而不是Key本身排序。有序实际上是由一个双向链表实现的。</span>

<span class="n">OrderedDict</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="s1">&#39;abcde&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="s1">&#39;acdeb&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="s1">&#39;bacde&#39;</span>

<span class="n">OrderedDict</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># 默认从删除最后一个(key,value),并且返回删除的(key,value),last=False表示从首位开始删除</span>
</code></pre></div>
<p><strong>LRU缓存代码</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 总共耗时:0.0007581710815429688ms,虽然时间略长,但是内存节约下来了</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="c1"># 借助OrderedDict 我们可以快速实现一个LRUCache，OrderedDict内部其实也是使用循环双端链表实现的</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">od</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>  <span class="c1"># 如果没有返回 default，保持 dict 语义</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>   <span class="c1"># 每次访问就把key 放到最后表示最新访问</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">add_or_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="p">:</span>  <span class="c1"># update</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># insert</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">:</span>  <span class="c1"># full</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        一个简单的 LRU 实现。有一些问题需要思考下：</span>

<span class="sd">        - 这里为了简化默认参数只有一个数字 n，假如可以传入多个参数，如何确定缓存的key 呢？</span>
<span class="sd">        - 这里实现没有考虑线程安全的问题，要如何才能实现线程安全的 LRU 呢？当然如果不是多线程环境下使用是不需要考虑的</span>
<span class="sd">        - 假如这里没有用内置的 dict，你能使用 redis 来实现这个 LRU 吗，如果使用了 redis，我们可以存储更多数据到服务器。而使用字典实际上是缓存了Python进程里(localCache)。</span>
<span class="sd">        - 这里只是实现了 lru 策略，你能同时实现一个超时 timeout 参数吗？比如像是memcache 实现的 lazy expiration 策略</span>
<span class="sd">        - LRU有个缺点就是，对于周期性的数据访问会导致命中率迅速下降，有一种优化是 LRU-K，访问了次数达到 k 次才会将数据放入缓存</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">od</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_or_update</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">_</span>

<span class="nd">@LRUCache</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">35</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total time:</span><span class="si">{</span><span class="n">total_time</span><span class="si">}</span><span class="s2">ms&quot;</span><span class="p">)</span>
</code></pre></div>
<h3 id="_4">双端队列(具有队列和栈的性质)<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([])</span>
<span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1"># 在最右边添加一个元素，此时 d=deque(&#39;a&#39;)</span>
<span class="n">d</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span> <span class="c1"># 在最左边添加一个元素，此时 d=deque([&#39;b&#39;, &#39;a&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">)</span> <span class="c1">#查找指定区间的索引</span>
<span class="n">d</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">val</span><span class="p">)</span> <span class="c1"># 再index之前插入val元素</span>
<span class="n">d</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">])</span> <span class="c1"># 在最右边添加所有元素，此时 d=deque([&#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">extendleft</span><span class="p">([</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">])</span> <span class="c1"># 在最左边添加所有元素，此时 d=deque([&#39;f&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># 将最右边的元素取出，返回 &#39;d&#39;，此时 d=deque([&#39;f&#39;, &#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="c1"># 将最左边的元素取出，返回 &#39;f&#39;，此时 d=deque([&#39;e&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># 把左边n个元素放右边（+则把右边元素放左边），此时 d=deque([&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;b&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1"># 队列中&#39;a&#39;的个数，返回 1</span>
<span class="n">d</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span> <span class="c1"># 从队列中将&#39;c&#39;删除，此时 d=deque([&#39;a&#39;, &#39;e&#39;, &#39;b&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="c1"># 将队列倒序，此时 d=deque([&#39;b&#39;, &#39;e&#39;, &#39;a&#39;])</span>
<span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># 浅拷贝</span>
<span class="n">d</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># 将队列清空，此时 d=deque([])</span>
</code></pre></div>
<p>使用deque的旋转解决约瑟夫环问题</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot; 约瑟夫算法</span>
<span class="sd">据说著名犹太历史学家 Josephus 有过以下的故事：</span>
<span class="sd">在罗马人占领桥塔帕特后，39个犹太人与 Josephus 及他的朋友躲到一个洞中，</span>
<span class="sd">39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，</span>
<span class="sd">由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，</span>
<span class="sd">直到所有人都自杀身亡为止。然而 Josephus 和他的朋友并不想自杀，</span>
<span class="sd">问他俩安排的哪两个位置可以逃过这场死亡游戏？</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="k">def</span> <span class="nf">ysf</span><span class="p">(</span><span class="n">totalNum</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">totalNum</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># 将每个人依次编号，放入到队列中</span>
    <span class="k">while</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">d</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">mod</span><span class="p">)</span> <span class="c1"># 队列向左旋转b步</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span> <span class="c1"># 将最右边的删除，即自杀的人</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">ysf</span><span class="p">(</span><span class="mi">41</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># 输出的是自杀的顺序。最后两个是16和31，说明这两个位置可以保证他俩的安全。</span>
</code></pre></div>
<h3 id="_5">哈希表(散列表)<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>有没有一种方法可以快速定位和删除元素吗？给每个元素一种『逻辑下标』，然后直接找到它，哈希表就是这种实现。它通过一个哈希函数来计算一个元素应该放在数组哪个位置，当然对于一个特定的元素，哈希函数每次计算的下标必须要一样才可以，而且范围不能超过给定的数组长度。</p>
<p><strong>举例子</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 哈希函数：h(key) = key % M,这样就保证了每个元素的下标固定，但是有弊端:下标发生冲突怎么办呢？</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">13</span>
<span class="n">h</span><span class="p">(</span><span class="mi">765</span><span class="p">)</span> <span class="o">=</span> <span class="mi">765</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">h</span><span class="p">(</span><span class="mi">431</span><span class="p">)</span> <span class="o">=</span> <span class="mi">431</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">h</span><span class="p">(</span><span class="mi">96</span><span class="p">)</span> <span class="o">=</span> <span class="mi">96</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">h</span><span class="p">(</span><span class="mi">142</span><span class="p">)</span> <span class="o">=</span> <span class="mi">142</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">h</span><span class="p">(</span><span class="mi">579</span><span class="p">)</span> <span class="o">=</span> <span class="mi">579</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">h</span><span class="p">(</span><span class="mi">226</span><span class="p">)</span> <span class="o">=</span> <span class="mi">226</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">h</span><span class="p">(</span><span class="mi">903</span><span class="p">)</span> <span class="o">=</span> <span class="mi">903</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">h</span><span class="p">(</span><span class="mi">388</span><span class="p">)</span> <span class="o">=</span> <span class="mi">388</span> <span class="o">%</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">11</span>
</code></pre></div>
<p><img alt="image-20200130115350169" src="../assets/image-20200130115350169.png" /></p>
<p><img alt="image-20200130115434603" src="../assets/image-20200130115434603.png" /></p>
<ul>
<li>但是如果哈希函数选不好的话，可能就导致冲突太多一个链变得太长，这样查找就不再是 O(1) 的了</li>
</ul>
<p><strong>开放寻址法</strong></p>
<p>它的基本思想是当一个槽被占用的时候，采用一种方式来寻找下一个可用的槽。 （这里槽指的是数组中的一个位置），根据找下一个槽的方式不同，分为:</p>
<p><img alt="image-20200130115815169" src="../assets/image-20200130115815169.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 本次选用 二次探查函数，代码举例如下</span>
<span class="n">inserted_index_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">13</span>

<span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">13</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="n">M</span>

<span class="n">to_insert</span> <span class="o">=</span> <span class="p">[</span><span class="mi">765</span><span class="p">,</span> <span class="mi">431</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">579</span><span class="p">,</span> <span class="mi">226</span><span class="p">,</span> <span class="mi">903</span><span class="p">,</span> <span class="mi">388</span><span class="p">]</span>
<span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">to_insert</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
    <span class="n">first_index</span> <span class="o">=</span> <span class="n">index</span> <span class="c1"># 倘若冲突了，使用first_index参与计算</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">inserted_index_set</span><span class="p">:</span>   <span class="c1"># 如果计算发现已经占用，继续计算得到下一个可用槽的位置</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">h(</span><span class="si">{number}</span><span class="s1">) = </span><span class="si">{number}</span><span class="s1"> % M = </span><span class="si">{index}</span><span class="s1"> collision&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="n">number</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">))</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_index</span> <span class="o">+</span>  <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">M</span>   <span class="c1"># 根据二次方探查的公式重新计算下一个需要插入的位置</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;h(</span><span class="si">{number}</span><span class="s1">) = </span><span class="si">{number}</span><span class="s1"> % M = </span><span class="si">{index}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number</span><span class="o">=</span><span class="n">number</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">))</span>
        <span class="n">inserted_index_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</code></pre></div>
<p><img alt="image-20200130120011177" src="../assets/image-20200130120011177.png" /></p>
<p><strong>装载因子</strong></p>
<p>如果继续往我们的哈希表里塞东西会发生什么？空间不够用。这里我们定义一个负载因子的概念(load factor)，其实很简单，就是已经使用的槽数比哈希表大小。 比如我们上边的例子插入了 8 个元素，哈希表总大小是 13， 它的 load factor 就是 <code>8/13≈0.62</code>。当我们继续往哈希表插入数据的时候，很快就不够用了。 通常当负载因子开始超过 0.8 的时候，就要新开辟空间并且重新进行散列了。重哈希规则:<code>cpython中规则</code>:<code>Currently set to used*3</code></p>
<p><strong>代码阐述</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># 从数组和列表章复制的代码</span>


<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[</span><span class="n">init</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>


<span class="k">class</span> <span class="nc">Slot</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;定义一个 hash 表数组的槽(slot 这里指的就是数组的一个位置)</span>
<span class="sd">    hash table 就是一个 数组，每个数组的元素（也叫slot槽）是一个对象，对象包含两个属性 key 和 value。</span>

<span class="sd">    注意，一个槽有三种状态，看你能否想明白。相比链接法解决冲突，探查法删除一个 key 的操作稍微复杂。</span>
<span class="sd">    1.从未使用 HashMap.UNUSED。此槽没有被使用和冲突过，查找时只要找到 UNUSED 就不用再继续探查了</span>
<span class="sd">    2.使用过但是 remove 了，此时是 HashMap.EMPTY，该探查点后边的元素仍然可能是有key的，需要继续查找</span>
<span class="sd">    3.槽正在使用 Slot 节点</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">HashTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">UNUSED</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># 没被使用过</span>
    <span class="n">EMPTY</span> <span class="o">=</span> <span class="n">Slot</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># 使用却被删除过</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">HashTable</span><span class="o">.</span><span class="n">UNUSED</span><span class="p">)</span>   <span class="c1"># 保持 2*i 次方</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span> <span class="c1"># 装载因子</span>
    <span class="k">def</span> <span class="nf">_load_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># load_factor 超过 0.8 重新分配，自身数值长度/Array总长度</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="c1"># 哈希函数</span>
    <span class="k">def</span> <span class="nf">_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        解释一个 slot 为 UNUSED 和 EMPTY 的区别</span>
<span class="sd">        因为使用的是二次探查的方式，假如有两个元素 A，B 冲突了，首先A hash 得到是 slot 下标5，A 放到了第5个槽，之后插入 B 因为冲突了，所以继续根据二次探查方式放到了 slot8。</span>
<span class="sd">        然后删除 A，槽 5 被置为 EMPTY。然后我去查找 B，第一次 hash 得到的是 槽5，但是这个时候我还是需要第二次计算 hash 才能找到 B。但是如果槽是 UNUSED 我就不用继续找了，</span>
<span class="sd">        我认为 B 就是不存在的元素。这个就是 UNUSED 和 EMPTY 的区别。</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">origin_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1"># origin_index 判断是否又走到了起点，如果查找一圈了都找不到则无此元素</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">UNUSED</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">EMPTY</span><span class="p">:</span>  <span class="c1"># 注意如果是 EMPTY，继续寻找下一个槽</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">_len</span> <span class="c1"># 本次使用的二次探查法使用规则</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">origin_index</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>  <span class="c1"># 找到了key</span>
                <span class="k">return</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">_len</span>  <span class="c1"># 没有找到继续找下一个位置</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">origin_index</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_find_slot_for_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slot_can_insert</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>  <span class="c1"># 直到找到一个可以用的槽</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">_len</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">_slot_can_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">EMPTY</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">UNUSED</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>  <span class="c1"># in operator，实现之后可以使用 in 操作符判断</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># update</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot_for_insert</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Slot</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_factor</span> <span class="o">&gt;=</span> <span class="mf">0.8</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rehash</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">old_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span>
        <span class="n">newsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">newsize</span><span class="p">,</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">UNUSED</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="n">old_table</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">UNUSED</span> <span class="ow">and</span> <span class="n">slot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">EMPTY</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_slot_for_insert</span><span class="p">(</span><span class="n">slot</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">()</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">EMPTY</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">HashTable</span><span class="o">.</span><span class="n">EMPTY</span><span class="p">,</span> <span class="n">HashTable</span><span class="o">.</span><span class="n">UNUSED</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">slot</span><span class="o">.</span><span class="n">key</span>


<span class="k">def</span> <span class="nf">test_hash_table</span><span class="p">():</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">HashTable</span><span class="p">()</span>
    <span class="n">h</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">h</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">h</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hehe&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">h</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">h</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">h</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s1">&#39;beg&#39;</span><span class="p">,</span>
        <span class="n">test_hash_table</span><span class="p">(),</span>
        <span class="s1">&#39;end&#39;</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div>
<h3 id="dict-set">dict + set<a class="headerlink" href="#dict-set" title="Permanent link">&para;</a></h3>
<p><strong>dict</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">D</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1">#移除D中的所有项  </span>
<span class="n">D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#返回D的副本  </span>
<span class="n">D</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">seq</span><span class="p">[,</span><span class="n">val</span><span class="p">])</span> <span class="c1">#返回从seq中获得的键和被设置为val的值的字典。可做类方法调用  </span>
<span class="n">D</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">[,</span><span class="n">default</span><span class="p">])</span> <span class="c1">#如果D[key]存在，将其返回；否则返回给定的默认值None  </span>
<span class="n">D</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="c1">#检查D是否有给定键key  </span>
<span class="n">D</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="c1">#返回表示D项的(键，值)对列表  </span>
<span class="n">D</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span> <span class="c1">#从D.items()返回的(键，值)对中返回一个可迭代的对象  </span>
<span class="n">D</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span> <span class="c1">#从D的键中返回一个可迭代对象  </span>
<span class="n">D</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span> <span class="c1">#从D的值中返回一个可迭代对象  </span>
<span class="n">D</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1">#返回D键的列表  </span>
<span class="n">D</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">[,</span><span class="n">d</span><span class="p">])</span> <span class="c1">#移除并且返回对应给定键key或给定的默认值D的值  </span>
<span class="n">D</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span> <span class="c1">#从D中移除任意一项，并将其作为(键，值)对返回  </span>
<span class="n">D</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">[,</span><span class="n">default</span><span class="p">])</span> <span class="c1">#如果D[key]存在则将其返回；否则返回默认值None  </span>
<span class="n">D</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="c1">#将other中的每一项加入到D中。  </span>
<span class="n">D</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="c1">#返回D中值的列表</span>
</code></pre></div>
<p><strong>set</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 特点：一个无序不重复元素集</span>
<span class="c1"># 构造</span>
<span class="nb">set</span><span class="p">()</span>               <span class="c1">#空集合定义</span>
<span class="n">Set1</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">}</span>
<span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span>
<span class="n">Set3</span> <span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>      <span class="c1">#例如：set(&#39;spam&#39;) ==set([&#39;a&#39;, &#39;p&#39;, &#39;s&#39;, &#39;m&#39;])=={&#39;a&#39;, &#39;p&#39;, &#39;s&#39;, &#39;m&#39;}   str--&gt;字符list--&gt;set</span>
<span class="n">t</span><span class="o">=</span><span class="n">s</span>                 <span class="c1">#t为集合s的一个引用</span>
<span class="n">t</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>          <span class="c1">#t为集合s的一个浅复制  </span>

<span class="c1"># 增</span>
<span class="n">t</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>            <span class="c1"># 添加一项  </span>
<span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>         <span class="c1"># 在s中添加多项  </span>

<span class="c1"># 删</span>
<span class="n">s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>         <span class="c1">#删除集合中的元素 x,返回集合 , 如果不存在则引发 KeyError  </span>
<span class="n">s</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>        <span class="c1">#删除集合中的元素 x,返回集合，如果不存在返回集合本身</span>
<span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>             <span class="c1">#删除集合中的任一不确定的元素, 返回集合，如果为空则引发 KeyError  </span>
<span class="n">s</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>           <span class="c1">#清空集合  </span>

<span class="c1"># 查</span>
<span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>             <span class="c1">#set 的长度  </span>
<span class="nb">hash</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>            <span class="c1">#返回 s 的 hash 值  </span>

<span class="c1"># 逻辑运算</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">t</span> <span class="o">|</span> <span class="n">s</span>          <span class="c1"># t 和 s的并集   s.union(t)  </span>
<span class="n">b</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&amp;</span> <span class="n">s</span>          <span class="c1"># t 和 s的交集  s.intersection(t) )  </span>
<span class="n">c</span> <span class="o">=</span> <span class="n">t</span> <span class="err">–</span> <span class="n">s</span>          <span class="c1"># 求差集（项在t中，但不在s中）  s.difference(t)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">t</span> <span class="o">^</span> <span class="n">s</span>          <span class="c1"># 对称差集（项在t或s中，但不会同时出现在二者中）  s.symmetric_difference(t) </span>
<span class="n">s</span><span class="o">|=</span><span class="n">t</span>               <span class="c1"># 将t添加到s中  s.update(t)  </span>
<span class="n">s</span> <span class="o">&lt;=</span> <span class="n">t</span>             <span class="c1">#s是t的子集  返回bool  s.issubset(t)  </span>
<span class="n">s</span> <span class="o">&gt;=</span> <span class="n">t</span>             <span class="c1">#s是t的父集   返回bool  s.issuperset(t) </span>
<span class="n">s</span><span class="o">==</span><span class="n">t</span>               <span class="c1">#s与t互为子集</span>
<span class="n">s</span><span class="o">!=</span><span class="n">t</span>               <span class="c1">#集合s与t不相等</span>
<span class="n">x</span> <span class="ow">in</span> <span class="n">s</span>             <span class="c1"># x 在集合 s 中   返回bool </span>
<span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span>         <span class="c1"># x 不在集合 s 中  返回bool </span>
</code></pre></div>
<h3 id="_6">递归<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<ul>
<li>递归必须包含一个基本的出口(base case)，否则就会无限递归，最终导致**栈溢出**。</li>
<li>递归必须包含一个可以分解的问题(recursive case)。 </li>
<li>递归必须必须要向着递归出口靠近(toward the base case)。 </li>
</ul>
<p><img alt="image-20200202085003321" src="../assets/image-20200202085003321.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<p><strong>打印十个数组理解递归</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 正序打印</span>
<span class="k">def</span> <span class="nf">print_num_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">print_num_recursive</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="c1"># 倒序打印</span>
<span class="k">def</span> <span class="nf">print_num_recursive_revserve</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">print_num_recursive_revserve</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 尾递归:就是递归调用放在了函数的最后</span>
<span class="c1"># 尾递归作用:</span>
<span class="c1"># 普通的递归, 每一级递归都产生了新的局部变量, 必须创建新的调用栈, 随着递归深度的增加, 创建的栈越来越多, 造成爆栈。虽然尾递归调用也会创建新的栈, 但是我们可以优化使得尾递归的每一级调用共用一个栈!, 如此便可解决爆栈和递归深度限制的问题! 不幸的是 python 默认不支持尾递归优化（见延伸阅读），不过一般尾递归我们可以用一个迭代来优化它。</span>
</code></pre></div>
<p><img alt="image-20200202085240789" src="../assets/image-20200202085240789.png" /></p>
<p><strong>汉诺塔问题</strong></p>
<p><img alt="image-20200202085557188" src="../assets/image-20200202085557188.png" /></p>
<p><img alt="image-20200202085546588" src="../assets/image-20200202085546588.png" /></p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;递归方法:</span>
<span class="sd">把上边的 n-1 个盘子从 S 移动到 I，借助 D 杆</span>
<span class="sd">把最底下的盘子从 S 移动到 D</span>
<span class="sd">把 n-1 个盘子从 I 移动到 D，借助 S</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">hanoi_move</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">intermediate</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 递归出口，只剩一个盘子</span>
        <span class="n">hanoi_move</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">intermediate</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Move </span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>
        <span class="n">hanoi_move</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">intermediate</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
<span class="n">hanoi_move</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="c1"># 输出，建议你手动模拟下。三个盘子 A(Source), B(intermediate), C(Destination)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Move A -&gt; C</span>
<span class="sd">Move A -&gt; B</span>
<span class="sd">Move C -&gt; B</span>
<span class="sd">Move A -&gt; C</span>
<span class="sd">Move B -&gt; A</span>
<span class="sd">Move B -&gt; C</span>
<span class="sd">Move A -&gt; C</span>
<span class="sd">&quot;&quot;&quot;</span>
</code></pre></div>
<h3 id="_7">查找+排序<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p><strong>二分查找</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sorted_array</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">beg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">beg</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">beg</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># beg + (end-beg)/2， 为了屏蔽 python 2/3 差异我用了强转</span>
        <span class="k">if</span> <span class="n">sorted_array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">sorted_array</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beg</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">test_binary_search</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

    <span class="c1"># 正常值</span>
    <span class="k">assert</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># 异常值</span>
    <span class="k">assert</span> <span class="n">binary_search</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># 边界值</span>
    <span class="k">assert</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div>
<p><strong>bisect(二分模块)</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 这个模块的输入是排序的，默认都是inplace=True</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">bisect</span><span class="o">.</span><span class="n">insort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># 插入但不改变现有排序 data-&gt;[2,3,4,9,7]</span>
<span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 0 查找该数值将会插入的位置并返回，而不会插入。data-&gt;[2,3,4,9,7]</span>
<span class="c1"># 下面两个函数用入处理将会插入重复数值的情况，返回将会插入的位置</span>
<span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># 2 [2,3,4,4,9,7]</span>
<span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="c1"># 3 [2,3,4,4,9,7]</span>
</code></pre></div>
<p><strong>基本排序(简单但耗时:冒泡/选择/插入)</strong></p>
<p><strong>冒泡排序(O(N^2))</strong></p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">对一个数组进行 n-1 轮迭代，每次比较相邻两个元素， 如果相邻的元素前者大于后者，就交换它们。因为直接在元素上操作而不是返回新的数组，所以是一个 inplace 的操作。 这里冒泡的意思其实就是每一轮冒泡一个最大的元素就会通过不断比较和交换相邻元素使它转移到最右边。</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c1"># O(n^2), n(n-1)/2 = 1/2(n^2 + n)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>    <span class="c1"># 我打印出来让你看清楚每一轮最高、次高、次次高...的小朋友会冒泡到右边</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>  <span class="c1"># 这里之所以 n-1 还需要 减去 i 是因为每一轮冒泡最大的元素都会冒泡到最后，无需再比较</span>
            <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_bubble_sort</span><span class="p">():</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># 注意 python3 返回迭代器，所以我都用 list 强转了，python2 range 返回的就是 list</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>   <span class="c1"># shuffle inplace 操作，打乱数组</span>
    <span class="n">bubble_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">seq</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>  <span class="c1"># 注意呦，内置的 sorted 就不是 inplace 的，它返回一个新的数组，不影响传入的参数</span>

<span class="sd">&quot;&quot;&quot; 我打印出来让你看到每次从最高到次高的小盆友就这么排好序了，因为是随机数，你第一个没有排序的数组应该和我的不一样</span>
<span class="sd">[3, 4, 5, 0, 9, 1, 7, 8, 6, 2]</span>
<span class="sd">[3, 4, 0, 5, 1, 7, 8, 6, 2, 9]</span>
<span class="sd">[3, 0, 4, 1, 5, 7, 6, 2, 8, 9]</span>
<span class="sd">[0, 3, 1, 4, 5, 6, 2, 7, 8, 9]</span>
<span class="sd">[0, 1, 3, 4, 5, 2, 6, 7, 8, 9]</span>
<span class="sd">[0, 1, 3, 4, 2, 5, 6, 7, 8, 9]</span>
<span class="sd">[0, 1, 3, 2, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">&quot;&quot;&quot;</span>
</code></pre></div>
<p><strong>选择排序(O(N^2))</strong></p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"> 每次我们找到最小的元素插入迭代的起始位置，这样每个位置从它自己的位置开始它就是最小的了，一圈下来数组就有序了。 选择可以理解为 一个 0 到 n-1 的迭代，每次向后查找选择一个最小的元素。</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span>    <span class="c1"># 我们假设当前下标的元素是最小的</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>    <span class="c1"># 从 i 的后边开始找到最小的元素，得到它的下标</span>
            <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]:</span>
                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span>    <span class="c1"># 一个 j 循环下来之后就找到了最小的元素它的下标</span>
        <span class="k">if</span> <span class="n">min_idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>    <span class="c1"># swap</span>
            <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_select_sort</span><span class="p">():</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">select_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">seq</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">[4, 7, 5, 3, 6, 0, 2, 9, 8, 1]</span>
<span class="sd">[0, 7, 5, 3, 6, 4, 2, 9, 8, 1]</span>
<span class="sd">[0, 1, 5, 3, 6, 4, 2, 9, 8, 7]</span>
<span class="sd">[0, 1, 2, 3, 6, 4, 5, 9, 8, 7]</span>
<span class="sd">[0, 1, 2, 3, 6, 4, 5, 9, 8, 7]</span>
<span class="sd">[0, 1, 2, 3, 4, 6, 5, 9, 8, 7]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 9, 8, 7]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 9, 8, 7]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>

<span class="sd">&quot;&quot;&quot;</span>
</code></pre></div>
<p><strong>插入排序(O(N^2))</strong></p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">每次挑选下一个元素插入已经排序的数组中,初始时已排序数组只有一个元素:</span>
<span class="sd">想象你手里有一些扑克牌，它们顺序是散乱的，现在需要你把它们整理成有序的，你会怎么做呢？ 首先拿最顶上的一张，然后拿第二张，第二张点数大，你就把第二张放在第一张的下边，否则放在第一张上边。 当你拿第三张的时候，你同样会找到适合它大小的位置插入进去。</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; 每次挑选下一个元素插入已经排序的数组中,初始时已排序数组只有一个元素&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    <span class="c1"># 保存当前位置的值，因为转移的过程中它的位置可能被覆盖</span>
        <span class="c1"># 找到这个值的合适位置，使得前边的数组有序 [0,i] 有序</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">seq</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 如果前边的元素比它大，就让它一直前移</span>
            <span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">seq</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>    <span class="c1"># 找到了合适的位置赋值就好</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot; 不断把新元素放到已经有序的数组中</span>
<span class="sd">[1, 7, 3, 0, 9, 4, 8, 2, 6, 5]</span>
<span class="sd">[1, 7, 3, 0, 9, 4, 8, 2, 6, 5]</span>
<span class="sd">[1, 3, 7, 0, 9, 4, 8, 2, 6, 5]</span>
<span class="sd">[0, 1, 3, 7, 9, 4, 8, 2, 6, 5]</span>
<span class="sd">[0, 1, 3, 7, 9, 4, 8, 2, 6, 5]</span>
<span class="sd">[0, 1, 3, 4, 7, 9, 8, 2, 6, 5]</span>
<span class="sd">[0, 1, 3, 4, 7, 8, 9, 2, 6, 5]</span>
<span class="sd">[0, 1, 2, 3, 4, 7, 8, 9, 6, 5]</span>
<span class="sd">[0, 1, 2, 3, 4, 6, 7, 8, 9, 5]</span>
<span class="sd">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">&quot;&quot;&quot;</span>
</code></pre></div>
<p><strong>高级排序算法(归并排序/快速排序)</strong></p>
<p><strong>归并排序(分治思路:O(n*log2n))</strong></p>
<ul>
<li><strong>分解</strong>：将待排序的 n 个元素分成各包含 n/2 个元素的子序列</li>
<li><strong>解决</strong>：使用归并排序递归排序两个子序列</li>
<li><strong>合并</strong>：合并两个已经排序的子序列以产生已排序的答案</li>
</ul>
<p><img alt="image-20200203100100596" src="../assets/image-20200203100100596.png" /></p>
<p><img alt="image-20200203100125715" src="../assets/image-20200203100125715.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 归并排序使用递归实现</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>   <span class="c1"># 只有一个元素是递归出口</span>
        <span class="k">return</span> <span class="n">seq</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># 前半部分分开</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">left_half</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">right_half</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>

        <span class="c1"># 后半部分合并:合并两个有序的数组</span>
        <span class="n">new_seq</span> <span class="o">=</span> <span class="n">merge_sorted_list</span><span class="p">(</span><span class="n">left_half</span><span class="p">,</span> <span class="n">right_half</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_seq</span>


<span class="k">def</span> <span class="nf">merge_sorted_list</span><span class="p">(</span><span class="n">sorted_a</span><span class="p">,</span> <span class="n">sorted_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; 合并两个有序序列，返回一个新的有序序列</span>

<span class="sd">    :param sorted_a:</span>
<span class="sd">    :param sorted_b:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length_a</span><span class="p">,</span> <span class="n">length_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 可以看做是从0开始的指针</span>
    <span class="n">new_sorted_seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length_a</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">length_b</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sorted_a</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sorted_b</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span>
            <span class="n">new_sorted_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_a</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_sorted_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_b</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 如果 a或b 中还有剩余元素，需要放到最后</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">length_a</span><span class="p">:</span>
        <span class="n">new_sorted_seq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sorted_a</span><span class="p">[</span><span class="n">a</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_sorted_seq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sorted_b</span><span class="p">[</span><span class="n">b</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">new_sorted_seq</span>

<span class="k">def</span> <span class="nf">test_merge_sort</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</code></pre></div>
<p><strong>快速排序(分治思想,应用广泛:O(n*logn))</strong></p>
<ul>
<li>选择基准值 pivot(<strong>第一个元素</strong>) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。这个过程称之为 partition</li>
<li>对这两个子数组进行快速排序。</li>
<li>合并结果</li>
</ul>
<p><img alt="image-20200203100613399" src="../assets/image-20200203100613399.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 实现方式1:不足</span>
<span class="c1"># 第一是它需要额外的存储空间，我们想实现 inplace 原地排序。</span>
<span class="c1"># 第二是它的 partition 操作每次都要两次遍历整个数组，我们想改善一下。</span>
<span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">array</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># NOTE: 递归出口，空数组或者只有一个元素的数组都是有序的</span>
        <span class="k">return</span> <span class="n">array</span>
    <span class="n">pivot_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">]</span>
    <span class="n">less_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span> <span class="ow">and</span> <span class="n">pivot_idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
    <span class="n">great_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span> <span class="ow">and</span> <span class="n">pivot_idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">less_part</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">great_part</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_quicksort</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># 实现方式2:优化1</span>
<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;对给定数组执行 partition 操作，返回新的 pivot 位置&quot;&quot;&quot;</span>
    <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">beg</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">pivot_index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># 开区间，最后一个元素位置是 end-1     [0, end-1] or [0: end)，括号表示开区间</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># 从左边找到比 pivot 大的</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>

    <span class="n">array</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">right</span>   <span class="c1"># 新的 pivot 位置</span>

<span class="k">def</span> <span class="nf">quicksort_inplace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>    <span class="c1"># 注意这里我们都用左闭右开区间，end 传入 len(array)</span>
    <span class="k">if</span> <span class="n">beg</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>    <span class="c1"># beg == end 的时候递归出口</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">quicksort_inplace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">beg</span><span class="p">,</span> <span class="n">pivot</span><span class="p">)</span>
        <span class="n">quicksort_inplace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_quicksort_inplace</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">sorted_seq</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="n">quicksort_inplace</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">sorted_seq</span>
</code></pre></div>
<h3 id="_8">树与二叉树<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p><img alt="image-20200204142519774" src="../assets/image-20200204142519774.png" /></p>
<ul>
<li>根节点(root): 树的最上层的节点，任何非空的树都有一个节点</li>
<li>路径(path): 从起始节点到终止节点经历过的边</li>
<li>父亲(parent)：除了根节点，每个节点的上一层边连接的节点就是它的父亲(节点)</li>
<li>孩子(children): 每个节点由边指向的下一层节点</li>
<li>兄弟(siblings): 同一个父亲并且处在同一层的节点</li>
<li>子树(subtree): 每个节点包含它所有的后代组成的子树</li>
<li>叶子节点(leaf node): 没有孩子的节点成为叶子节点</li>
</ul>
<p><strong>二叉树:它的每个节点最多只能包含两个孩子</strong></p>
<p><img alt="image-20200204143211481" src="../assets/image-20200204143211481.png" /></p>
<p>一棵 size 为 n 的二叉树高度最多可以是 n，最小的高度是⌊lgn⌋+1，这里 log 以 2 为底简写为 lgn</p>
<ul>
<li><strong>满二叉树</strong>：如果每个内部节点（非叶节点）都包含两个孩子，就成为满二叉树。</li>
</ul>
<p><img alt="image-20200204143446720" src="../assets/image-20200204143446720.png" /></p>
<ul>
<li><strong>完美二叉树</strong>：当所有的叶子节点都在同一层就是完美二叉树，毫无间隙填充了 h 层。</li>
</ul>
<p><img alt="image-20200204143501424" src="../assets/image-20200204143501424.png" /></p>
<ul>
<li><strong>完全二叉树(堆的实现)</strong>：当一个高度为 h 的完美二叉树减少到 h-1，并且最底层的槽被毫无间隙地从左到右填充，我们就叫它完全二叉树。</li>
</ul>
<p><img alt="image-20200204143724230" src="../assets/image-20200204143724230.png" /></p>
<p><strong>代码实现二叉树</strong></p>
<p><img alt="image-20200204143802783" src="../assets/image-20200204143802783.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 链表实现</span>
<span class="k">class</span> <span class="nc">BinTreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">right</span>

<span class="c1"># 二叉树表示</span>
<span class="n">node_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
<span class="p">]</span>

<span class="k">class</span> <span class="nc">BinTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_from</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;通过节点信息构造二叉树</span>
<span class="sd">        第一次遍历我们构造 node 节点</span>
<span class="sd">        第二次遍历我们给 root 和 孩子赋值</span>
<span class="sd">        最后我们用 root 初始化这个类并返回一个对象</span>

<span class="sd">        :param node_list: {&#39;data&#39;: &#39;A&#39;, &#39;left&#39;: None, &#39;right&#39;: None, &#39;is_root&#39;: False}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="n">node_dict</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">BinTreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node_data</span><span class="p">[</span><span class="s1">&#39;is_root&#39;</span><span class="p">]:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_data</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_data</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="n">btree</span><span class="o">.</span><span class="n">preorder_trav</span><span class="p">(</span><span class="n">btree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>    <span class="c1"># 输出 A, B, D, E, H, C, F, G, I, J</span>
<span class="nb">print</span><span class="p">(</span><span class="n">btree</span><span class="p">)</span>
</code></pre></div>
<p><strong>二叉树的遍历(递归实现)</strong></p>
<p><img alt="image-20200204143802783" src="../assets/image-20200204143802783.png" /></p>
<ul>
<li>先(根)序遍历: 先处理根，之后是左子树，然后是右子树:<em>A, B, D, E, H, C, F, G, I, J</em></li>
<li>中(根)序遍历: 先处理左子树，之后是根，最后是右子树:<em>D B H E A F C I G J</em></li>
<li>后(根)序遍历: 先处理左子树，之后是右子树，最后是根:<em>D H E B F I J G C A</em></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># 先序遍历:root-&gt;left-&gt;right</span>
<span class="k">def</span> <span class="nf">preorder_trav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preorder_trav</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preorder_trav</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

<span class="c1"># 中序遍历:left-&gt;root-&gt;right</span>
<span class="k">def</span> <span class="nf">inorder_trav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inorder_trav</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inorder_trav</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

<span class="c1"># 后序遍历:left-&gt;right-&gt;root</span>
<span class="k">def</span> <span class="nf">postorder_trav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postorder_trav</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">postorder_trav</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

<span class="n">btree</span> <span class="o">=</span> <span class="n">BinTree</span><span class="o">.</span><span class="n">build_from</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>
<span class="n">btree</span><span class="o">.</span><span class="n">preorder_trav</span><span class="p">(</span><span class="n">btree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span> <span class="c1"># A, B, D, E, H, C, F, G, I, J</span>
<span class="n">btree</span><span class="o">.</span><span class="n">inorder_trav</span><span class="p">(</span><span class="n">btree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span> <span class="c1"># D B H E A F C I G J </span>
<span class="n">btree</span><span class="o">.</span><span class="n">postorder_trav</span><span class="p">(</span><span class="n">btree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span><span class="c1"># D H E B F I J G C A </span>
</code></pre></div>
<p><strong>反转二叉树</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">subtree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">subtree</span><span class="o">.</span><span class="n">left</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div>
<h3 id="_9">堆排序<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>堆是一种**完全二叉树(使用数组实现)**有最大堆和最小堆两种。</p>
<ul>
<li>最大堆: <strong>对于每个非叶子节点 V，V 的值都比它的两个孩子大</strong>，称为 最大堆特性(heap order property) 最大堆里的根总是存储最大值，最小的值存储在叶节点。</li>
</ul>
<p><img alt="image-20200204151912158" src="../assets/image-20200204151912158.png" /></p>
<ul>
<li>最小堆：和最大堆相反，<strong>每个非叶子节点 V，V 的两个孩子的值都比它大</strong>。</li>
</ul>
<p><img alt="image-20200204151930422" src="../assets/image-20200204151930422.png" /></p>
<p><strong>堆的表示(完全二叉树)</strong></p>
<p><img alt="image-20200205143909633" src="../assets/image-20200205143909633.png" /></p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">因为完全二叉树的特性，树不会有间隙。对于数组里的一个下标 i，我们可以得到它的父亲和孩子的节点对应的下标</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="c1"># 超出下标表示没有对应的孩子节点。</span>
<span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># 取整</span>
<span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
</code></pre></div>
<p><strong>堆的插入</strong></p>
<p><img alt="image-20200204152344435" src="../assets/image-20200204152344435.png" /></p>
<p><strong>获取堆的最大值或最小值(堆的根节点是最大/最小值)</strong></p>
<p><img alt="image-20200204152728252" src="../assets/image-20200204152728252.png" /></p>
<p><strong>堆实现+堆排序</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># -*- coding:utf-8 -*-</span>

<span class="c1"># 第二章拷贝的 Array 代码</span>


<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">item</span>

<span class="c1">#####################################################</span>
<span class="c1"># heap 实现</span>
<span class="c1">#####################################################</span>


<span class="k">class</span> <span class="nc">MaxHeap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Heaps:</span>
<span class="sd">    完全二叉树，最大堆的非叶子节点的值都比孩子大，最小堆的非叶子结点的值都比孩子小</span>
<span class="sd">    Heap包含两个属性，order property 和 shape property(a complete binary tree)，在插入</span>
<span class="sd">    一个新节点的时候，始终要保持这两个属性</span>
<span class="sd">    插入操作：保持堆属性和完全二叉树属性, sift-up 操作维持堆属性</span>
<span class="sd">    extract操作：只获取根节点数据，并把树最底层最右节点copy到根节点后，sift-down操作维持堆属性</span>

<span class="sd">    用数组实现heap，从根节点开始，从上往下从左到右给每个节点编号，则根据完全二叉树的</span>
<span class="sd">    性质，给定一个节点i， 其父亲和孩子节点的编号分别是:</span>
<span class="sd">        parent = (i-1) // 2</span>
<span class="sd">        left = 2 * i + 1</span>
<span class="sd">        rgiht = 2 * i + 2</span>
<span class="sd">    使用数组实现堆一方面效率更高，节省树节点的内存占用，一方面还可以避免复杂的指针操作，减少</span>
<span class="sd">    调试难度。</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_siftup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 维持堆的特性</span>

    <span class="k">def</span> <span class="nf">_siftup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ndx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">ndx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">parent</span><span class="p">]:</span>    <span class="c1"># 如果插入的值大于 parent，一直交换</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">ndx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_siftup</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>    <span class="c1"># 递归</span>

    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;empty&#39;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># 保存 root 值</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">]</span>    <span class="c1"># 最右下的节点放到root后siftDown</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_siftdown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>    <span class="c1"># 维持堆特性</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_siftdown</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndx</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndx</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="c1"># determine which node contains the larger value</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">ndx</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="ow">and</span>     <span class="c1"># 有左孩子</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">right</span><span class="p">]):</span>  <span class="c1"># 原书这个地方没写实际上找的未必是largest</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">elif</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">ndx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">ndx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elements</span><span class="p">[</span><span class="n">ndx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_siftdown</span><span class="p">(</span><span class="n">largest</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_maxheap</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">MaxHeap</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">h</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>

<span class="c1"># 实现堆排序</span>
<span class="k">def</span> <span class="nf">heapsort_reverse</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">maxheap</span> <span class="o">=</span> <span class="n">MaxHeap</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
        <span class="n">maxheap</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxheap</span><span class="o">.</span><span class="n">extract</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">test_heapsort_reverse</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">heapsort_reverse</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="c1"># 使用自带库实现堆排序</span>
<span class="k">def</span> <span class="nf">heapsort_use_heapq</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="n">heappush</span><span class="p">,</span> <span class="n">heappop</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">heappush</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">heappop</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">test_heapsort_use_heapq</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">heapsort_use_heapq</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div>
<p><strong>python自带库:heapq</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="n">item</span><span class="p">)</span> <span class="c1">#往堆中插入一条新的值</span>
<span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>   <span class="c1">#从堆中弹出最小值</span>
<span class="n">heapreplace</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="n">item</span><span class="p">)</span>  <span class="c1">#从堆中弹出最小值，并往堆中插入item</span>
<span class="n">heappushpop</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="n">item</span><span class="p">)</span>  <span class="c1">#Python3中的heappushpop更高级</span>
<span class="n">heapify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1">#以线性时间将一个列表转化为堆</span>
<span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>    <span class="c1">#合并对个堆，然后输出</span>
<span class="n">nlargest</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">iterable</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>   <span class="c1">#返回可枚举对象中的n个最大值并返回一个结果集list</span>
<span class="n">nsmallest</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">iterable</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1">#返回可枚举对象中的n个最小值并返回一个结果集list</span>
</code></pre></div>
<p><strong>Top K问题</strong></p>
<p>面试题中有这样一类问题，让求出大量数据中的top k 个元素，比如一亿个数字中最大的100个数字。 对于这种问题有很多种解法，比如直接排序、mapreduce、trie 树、分治法等，当然如果内存够用直接排序是最简单的。 如果内存不够用呢？ 这里我们提一下使用固定大小的堆来解决这个问题的方式。</p>
<p>一开始的思路可能是，既然求最大的 k 个数，是不是应该维护一个包含 k 个元素的最大堆呢？ 稍微尝试下你会发现走不通。我们先用数组的前面 k 个元素建立最大堆，然后对剩下的元素进行比对，但是最大堆只能每次获取堆顶 最大的一个元素，如果我们取下一个大于堆顶的值和堆顶替换，你会发现堆底部的小数一直不会被换掉。如果下一个元素小于堆顶 就替换也不对，这样可能最大的元素就被我们丢掉了。</p>
<p>相反我们用最小堆呢？ 先迭代前 k 个元素建立一个最小堆，之后的元素如果小于堆顶最小值，跳过，否则替换堆顶元素并重新调整堆。你会发现最小堆里 慢慢就被替换成了最大的那些值，并且最后堆顶是最大的 topk 个值中的最小值。 （比如1000个数找10个，最后堆里剩余的是 [990, 991, 992, 996, 994, 993, 997, 998, 999, 995]，第一个 990 最小)</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">heapq</span>


<span class="k">class</span> <span class="nc">TopK</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;获取大量元素 topk 大个元素，固定内存</span>
<span class="sd">    思路：</span>
<span class="sd">    1. 先放入元素前 k 个建立一个最小堆</span>
<span class="sd">    2. 迭代剩余元素：</span>
<span class="sd">        如果当前元素小于堆顶元素，跳过该元素（肯定不是前 k 大）</span>
<span class="sd">        否则替换堆顶元素为当前元素，并重新调整堆</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minheap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterable</span> <span class="o">=</span> <span class="n">iterable</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minheap</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">:</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minheap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">min_val</span><span class="p">:</span>  <span class="c1"># 当然你可以直接 if val &gt; min_val操作，这里我只是显示指出跳过这个元素</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heapreplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minheap</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>  <span class="c1"># 返回并且pop堆顶最小值，推入新的 val 值并调整堆</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minheap</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>  <span class="c1"># 前面 k 个元素直接放入minheap</span>

    <span class="k">def</span> <span class="nf">get_topk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minheap</span>


<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>  <span class="c1"># 这里可以是一个可迭代元素，节省内存</span>
    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">TopK</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">get_topk</span><span class="p">())</span>  <span class="c1"># [990, 991, 992, 996, 994, 993, 997, 998, 999, 995]</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test</span><span class="p">()</span>
</code></pre></div>
<h3 id="_10">优先级队列<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>你可能比较奇怪，队列不是早就讲了嘛。这里之所以放到这里讲优先级队列，是因为虽然名字有队列，
但其实是使用堆来实现的。上一章讲完了堆，这一章我们就趁热打铁来实现一个优先级队列。</p>
<p><strong>实现优先级队列</strong></p>
<p>优先级队列(Priority Queue) 顾名思义，就是入队的时候可以给一个优先级，通常是个数字或者时间戳等，
当出队的时候我们希望按照给定的优先级出队，我们按照 TDD(测试驱动开发) 的方式先来写测试代码：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_priority_queue</span><span class="p">():</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;purple&#39;</span><span class="p">)</span>    <span class="c1"># priority, value</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">)</span>
    <span class="n">pq</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">pq</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pq</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">res</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;white&#39;</span><span class="p">]</span>
</code></pre></div>
<p>上边就是期望的行为，写完测试代码后我们来编写优先级队列的代码，按照出队的时候最大优先级先出的顺序：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxheap</span> <span class="o">=</span> <span class="n">MaxHeap</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># 注意这里把这个 tuple push 进去，python 比较 tuple 从第一个开始比较</span>
        <span class="c1"># 这样就很巧妙地实现了按照优先级排序</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>    <span class="c1"># 入队的时候会根据 priority 维持堆的特性</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxheap</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_priority</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxheap</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">with_priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">entry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maxheap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div>
<h3 id="on">二叉查找树(效率最高:O(N))<a class="headerlink" href="#on" title="Permanent link">&para;</a></h3>
<p>二叉查找树是这样一种二叉树结构，它的每个节点包含一个 key 和它附带的数据，对于每个内部节点 V：</p>
<ul>
<li>所有 key 小于 V 的都被存储在 V 的左子树</li>
<li>所有 key 大于 V 的都存储在 V 的右子树</li>
</ul>
<p><img alt="image-20200206213020012" src="../assets/image-20200206213020012.png" /></p>
<ul>
<li>说白了就是对于每个内部节点，左子树的 key 都比它小，右子树都比它大。 如果中序遍历(二叉树遍历讲过了)这颗二叉树，你会发现输出的顺序正好是有序的。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="k">class</span> <span class="nc">BSTNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">BST</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">build_from</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node_list</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">key_to_node_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_dict</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
            <span class="n">key_to_node_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>   <span class="c1"># 这里值暂时用 和 key一样的</span>

        <span class="k">for</span> <span class="n">node_dict</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">key_to_node_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node_dict</span><span class="p">[</span><span class="s1">&#39;is_root&#39;</span><span class="p">]:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">key_to_node_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">key_to_node_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="c1"># 从根节点开始，如果 search_key 大于当前 key，就去右子树查找，否则去左子树查找。 一直到当前节点是 None 了说明没找到对应 key。</span>
    <span class="k">def</span> <span class="nf">_bst_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># 没找到</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_search</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_search</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">subtree</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;实现 in 操作符&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
    <span class="c1"># 最小值就一直向着左子树找，最大值一直向右子树找，递归查找就行</span>
    <span class="k">def</span> <span class="nf">_bst_min_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">subtree</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># 找到左子树的头</span>
            <span class="k">return</span> <span class="n">subtree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_min_node</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bst_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_min_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="n">node</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="c1"># 插入节点的时候我们需要一直保持 BST 的性质，每次插入一个节点，我们都通过递归比较把它放到正确的位置。 你会发现新节点总是被作为叶子结点插入(因为插入的值总是会一直和比较，一直往下走)</span>
    <span class="k">def</span> <span class="nf">_bst_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; 插入并且返回根节点</span>

<span class="sd">        :param subtree:</span>
<span class="sd">        :param key:</span>
<span class="sd">        :param value:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># 插入的节点一定是根节点，包括 root 为空的情况</span>
            <span class="n">subtree</span> <span class="o">=</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">subtree</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_insert</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">subtree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_insert</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subtree</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>   <span class="c1"># 更新已经存在的 key</span>
            <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="c1"># 删除操作相比上边的操作要麻烦很多，首先需要定位一个节点，删除节点后，我们需要始终保持 BST 的性质。 删除一个节点涉及到三种情况：节点是叶节点,节点有一个孩子,节点有两个孩子</span>
    <span class="k">def</span> <span class="nf">_bst_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;删除节点并返回根节点&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">subtree</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_remove</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">subtree</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">subtree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_remove</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">subtree</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 找到了需要删除的节点</span>
            <span class="k">if</span> <span class="n">subtree</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">subtree</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>    <span class="c1"># 叶节点(最简单的情况)，返回 None 即只需要把它的父亲指向它的指针设置为 None 就好</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># 删除有一个孩子的节点时，我们拿掉需要删除的节点，之后把它的父亲指向它的孩子就行，因为根据 BST 左子树都小于节点，右子树都大于节点的特性，删除它之后这个条件依旧满足。</span>
            <span class="k">elif</span> <span class="n">subtree</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">subtree</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 只有一个孩子</span>
                <span class="k">if</span> <span class="n">subtree</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">subtree</span><span class="o">.</span><span class="n">left</span>  <span class="c1"># 返回它的孩子并让它的父亲指过去</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">subtree</span><span class="o">.</span><span class="n">right</span>
            <span class="c1"># 删除有两个孩子的内部节点:比较麻烦，后续解释</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># 俩孩子，寻找后继节点替换，并删除其右子树的后继节点，同时更新其右子树</span>
                <span class="n">successor_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_min_node</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
                <span class="n">subtree</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">subtree</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">successor_node</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">successor_node</span><span class="o">.</span><span class="n">value</span>
                <span class="n">subtree</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_remove</span><span class="p">(</span><span class="n">subtree</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">successor_node</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">subtree</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bst_remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>


<span class="n">NODE_LIST</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="mi">90</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="mi">41</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">41</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">29</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">29</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">23</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">23</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">37</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">90</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">71</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">71</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="mi">84</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="mi">84</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;is_root&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">test_bst_tree</span><span class="p">():</span>
    <span class="n">bst</span> <span class="o">=</span> <span class="n">BST</span><span class="o">.</span><span class="n">build_from</span><span class="p">(</span><span class="n">NODE_LIST</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node_dict</span> <span class="ow">in</span> <span class="n">NODE_LIST</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span>
    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">NODE_LIST</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>    <span class="c1"># 单例的 None 我们用 is 来比较</span>

    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">bst_min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">bst</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">bst_min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="n">bst</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">bst</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">bst</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
</code></pre></div>
<p><strong>删除含有两个孩子的内部节点</strong></p>
<p><img alt="image-20200206221702385" src="../assets/image-20200206221702385.png" /></p>
<p>这里我们用另一种非常巧妙的方式。 还记得上边提到的吗，如果你中序遍历 BST 并且输出每个节点的 key，你会发现就是一个有序的数组。 <code>[1 4 12 23 29 37 41 60 71 84 90 100]</code>。这里我们定义两个概念，逻辑前任(predecessor)和后继(successor)，请看下图:</p>
<p><img alt="image-20200206221750245" src="../assets/image-20200206221750245.png" /></p>
<p><code>12</code>在中序遍历中的逻辑前任和后继分别是<code>4</code> 和<code>23</code>节点。于是我们还有一种方法来删除 <code>12</code> 这个节点：</p>
<ul>
<li>找到待删除节点 N(12) 的后继节点 S(23)</li>
<li>复制节点 S 到节点 N</li>
<li>从 N 的右子树中删除节点 S，并更新其删除后继节点后的右子树</li>
</ul>
<p>说白了就是找到后继并且替换，这里之所以能保证这种方法是正确的，你会发现替换后依旧是保持了 BST 的性质。 有个问题是如何找到后继节点呢？待删除节点的右子树的最小的节点不就是后继嘛，上边我们已经实现了找到最小 key 的方法了。</p>
<p><img alt="image-20200206221817808" src="../assets/image-20200206221817808.png" /></p>
<h3 id="_11">图<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<p>简单地说就是有节点(node)和边(edge)组成的一种数据结构，相邻的节点称之为邻居。 注意图分为有向图和无向图， 比如有些路是单行道，有些是双行道，有向图我们用箭头指向，无向图就是一条直线连接。</p>
<p><img alt="image-20200206222432067" src="../assets/image-20200206222432067.png" /></p>
<ul>
<li>邻接表法：对于每个图中的点，将它的邻居放到一个链表里</li>
<li>邻接矩阵：对于 n 个点，构造一个 n * n 的矩阵，如果有从点 i 到点 j 的边，就将矩阵的位置 matrix[i][j] 置为 1.</li>
<li>用矩阵存储图是非常耗费空间的，大部分情况下矩阵是稀疏的，所以我们后边选择使用邻接表。</li>
</ul>
<p><strong>广度优先搜索(BFS)</strong></p>
<p>BFS 类似于树的层序遍历，从第一个节点开始，先访问离 A 最近的点，接着访问次近的点。我们先来构造一个图：</p>
<div class="highlight"><pre><span></span><code><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">],</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">],</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">],</span>
    <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
    <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div>
<p>如何『由近及远』地访问节点呢？我们先访问起点 A 的邻居，然后邻居访问完再访问邻居的邻居不就行了？ 就是这个思想，不过我们需要一个队列辅助，队列之前说过是一种先进先出结构，我们只需要把起点的邻居先入队， 当邻居访问完了再去访问邻居的邻居就可以了，对于已经访问过的节点，我们用一个 set 记录它就好了。代码如下</p>
<div class="highlight"><pre><span></span><code><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="n">GRAPH</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">],</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">],</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">],</span>
    <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
    <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">Queue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deque</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deque</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deque</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">search_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">search_queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">searched</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">search_queue</span><span class="p">:</span>   <span class="c1"># 队列不为空就继续</span>
        <span class="n">cur_node</span> <span class="o">=</span> <span class="n">search_queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cur_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">searched</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cur_node</span>
            <span class="n">searched</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cur_node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_node</span><span class="p">]:</span>
                <span class="n">search_queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;bfs:&#39;</span><span class="p">)</span>
<span class="n">bfs</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">bfs:</span>
<span class="sd">A</span>
<span class="sd">B</span>
<span class="sd">F</span>
<span class="sd">C</span>
<span class="sd">I</span>
<span class="sd">G</span>
<span class="sd">E</span>
<span class="sd">D</span>
<span class="sd">H</span>
<span class="sd">&quot;&quot;&quot;</span>
</code></pre></div>
<p><img alt="image-20200207145534841" src="../assets/image-20200207145534841.png" /></p>
<p><strong>深度优先搜索(DFS)</strong></p>
<p>深度优先搜索(DFS)是每遇到一个节点，如果没有被访问过，就直接去访问它的邻居节点，不断加深。代码其实很简单：</p>
<div class="highlight"><pre><span></span><code><span class="n">DFS_SEARCHED</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DFS_SEARCHED</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">DFS_SEARCHED</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">DFS_SEARCHED</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dfs:&#39;</span><span class="p">)</span>
<span class="n">dfs</span><span class="p">(</span><span class="n">GRAPH</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>  <span class="c1"># A B C I D G F E H</span>
</code></pre></div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../vim_cmake_git/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              vim_git_cmake
            </div>
          </div>
        </a>
      
      
        <a href="../java%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8Band%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              java简明教程and安卓开发
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.ca5457b8.min.js"></script>
      
    
  </body>
</html>