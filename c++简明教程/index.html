
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.0.3">
    
    
      
        <title>c++简明教程 - 个人笔记</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.1655a90d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.7fa14f5b.min.css">
        
          
          
          <meta name="theme-color" content="#009485">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="teal" data-md-color-accent="pink">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="个人笔记" class="md-header__button md-logo" aria-label="个人笔记">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            个人笔记
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              c++简明教程
            
          </span>
        </div>
      </div>
    </div>
    <div class="md-header__options">
      
    </div>
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="个人笔记" class="md-nav__button md-logo" aria-label="个人笔记">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    个人笔记
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      <label class="md-nav__link" for="__nav_1">
        一、计算机视觉专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="一、计算机视觉专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          一、计算机视觉专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        目标检测论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../OCR%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        OCR方向论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%BA%E8%84%B8%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        人脸方向论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        图像识别论文解读
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        深度学习基础
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      <label class="md-nav__link" for="__nav_2">
        二、AI代码专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="二、AI代码专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          二、AI代码专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../PyTorch%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B/" class="md-nav__link">
        PyTorch快速教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../PaddlePaddle%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B/" class="md-nav__link">
        PaddlePaddle快速教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../caffe%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" class="md-nav__link">
        Caffe快速教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../onnx%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" class="md-nav__link">
        ONNX简明教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81/" class="md-nav__link">
        深度学习工具代码
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../pandas%E3%80%81matplotlib%E7%AE%80%E6%B4%81%E7%AC%94%E8%AE%B0/" class="md-nav__link">
        PD+PLT简洁笔记
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      <label class="md-nav__link" for="__nav_3">
        三、常用工具专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="三、常用工具专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          三、常用工具专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%87%8F%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" class="md-nav__link">
        量化工具使用
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/" class="md-nav__link">
        实用工具教程
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/" class="md-nav__link">
        学习网站收集
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E5%BA%93%28albumentations%2BAugmentor%29/" class="md-nav__link">
        图像增强库
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      <label class="md-nav__link" for="__nav_4">
        四、编程语言专栏
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="四、编程语言专栏" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          四、编程语言专栏
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          c++简明教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        c++简明教程
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    基本知识
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    类和对象
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    模板
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stl" class="md-nav__link">
    STL标准模板库
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    多线程
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    文件和流
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    日期和时间
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opencv" class="md-nav__link">
    opencv常用属性
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../vim_cmake_git/" class="md-nav__link">
        vim_git_cmake
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../python%E5%88%B7%E9%A2%98/" class="md-nav__link">
        python刷题
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../java%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8Band%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/" class="md-nav__link">
        java简明教程and安卓开发
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    基本知识
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    类和对象
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    模板
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stl" class="md-nav__link">
    STL标准模板库
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    多线程
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    文件和流
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    日期和时间
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opencv" class="md-nav__link">
    opencv常用属性
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>c++简明教程</h1>
                
                <p><a href="https://www.jianshu.com/p/bd442e75d0b7">精炼博客</a></p>
<h3 id="_1">基本知识<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p><strong>#include的&lt;&gt;和" "</strong></p>
<ul>
<li><code>&lt;&gt;</code>先去系统目录中找头文件，如果没有再到当前目录下找。</li>
<li>而<code>" "</code>首先在当前目录下寻找，如果找不到，再到系统目录中寻找。</li>
</ul>
<p><strong>命名空间</strong></p>
<p>主要是用来区分不同库中相同名称的函数、类、变量等。**使用了命名空间即定义了上下文。**本质上，命名空间就是定义了一个范围。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// 第一个命名空间</span>
<span class="k">namespace</span> <span class="n">first_space</span><span class="p">{</span>
   <span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Inside first_space&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 第二个命名空间</span>
<span class="k">namespace</span> <span class="n">second_space</span><span class="p">{</span>
   <span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Inside second_space&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// 调用第一个命名空间中的函数</span>
   <span class="n">first_space</span><span class="o">::</span><span class="n">func</span><span class="p">();</span>

   <span class="c1">// 调用第二个命名空间中的函数</span>
   <span class="n">second_space</span><span class="o">::</span><span class="n">func</span><span class="p">();</span> 

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 嵌套的命名空间</span>
<span class="k">namespace</span> <span class="n">namespace_name1</span> <span class="p">{</span>
   <span class="c1">// 代码声明</span>
   <span class="k">namespace</span> <span class="n">namespace_name2</span> <span class="p">{</span>
      <span class="c1">// 代码声明</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 访问 namespace_name2 中的成员</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">namespace_name1</span><span class="o">::</span><span class="n">namespace_name2</span><span class="p">;</span>

<span class="c1">// 访问 namespace:name1 中的成员</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">namespace_name1</span><span class="p">;</span>
</code></pre></div>
<p><strong>常用基础知识</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 1.typedef 声明,使用 typedef 为一个已有的类型取一个新的名字</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">feet</span><span class="p">;</span> <span class="n">feet</span> <span class="n">distance</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>

<span class="c1">// 2.常量 const</span>
<span class="k">const</span> <span class="err">数据类型</span> <span class="err">常量名</span><span class="o">=</span><span class="err">常量值；</span> <span class="err">数据类型</span> <span class="k">const</span> <span class="err">常量名</span><span class="o">=</span><span class="err">常量值；</span> <span class="c1">// 两种定义，声明时必须赋值，声明后只读。</span>

<span class="c1">// 3.数据转换 </span>
<span class="c1">// 3.1 隐含转换从低到高 int a=3; float b = a;</span>
<span class="kt">char</span><span class="o">--&gt;</span><span class="kt">short</span><span class="o">--&gt;</span><span class="kt">int</span><span class="o">--&gt;</span><span class="kt">unsigned</span><span class="o">--&gt;</span><span class="kt">long</span><span class="o">--&gt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">--&gt;</span><span class="kt">float</span><span class="o">--&gt;</span><span class="kt">double</span>
<span class="c1">// 3.2 显示转换 类型说明符(表达式)。 float z=7.56; int a = int(z);</span>
<span class="c1">// 3.3 4种类型转换操作符；细分4种</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="err">类型说明符</span><span class="o">&gt;</span><span class="err">（表达式）</span><span class="c1">// 基本数据类型间的转换都适用：int(z) &lt;==&gt; static_cast&lt;int&gt;(z)</span>
<span class="k">const_cast</span><span class="o">&lt;</span><span class="err">类型说明符</span><span class="o">&gt;</span><span class="err">（表达式）</span>
<span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="err">类型说明符</span><span class="o">&gt;</span><span class="err">（表达式）</span>
<span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="err">类型说明符</span><span class="o">&gt;</span><span class="err">（表达式）</span>

<span class="c1">// 4.变量的存储类型，变量出了数据类型(int/float/double..)外还有存储类型，决定了其存储方式</span>
<span class="k">auto</span> <span class="c1">// 暂时性存储，其存储空间可以被若干变量多次覆盖使用。采用堆栈方式分配内存空间</span>
<span class="k">register</span> <span class="c1">// 存放在通用寄存器中</span>
<span class="k">extern</span> <span class="c1">// 在所有函数和程序段中都可以引用</span>
<span class="k">static</span> <span class="c1">// 在内存中以固定地址存放，整个程序运行期间都有效</span>

<span class="c1">// 5.枚举类型enum</span>
<span class="k">enum</span> <span class="err">枚举类型名</span> <span class="p">{</span><span class="err">变量值列表</span><span class="p">};</span> <span class="c1">// 枚举声明形式</span>
<span class="k">enum</span> <span class="nc">Weekday</span> <span class="p">{</span><span class="n">SUM</span><span class="p">,</span><span class="n">MON</span><span class="p">,</span><span class="n">TUE</span><span class="p">,</span><span class="n">WED</span><span class="p">,</span><span class="n">THU</span><span class="p">,</span><span class="n">FRI</span><span class="p">,</span><span class="n">SAT</span><span class="p">};</span> <span class="c1">// 举例子，枚举元素具有默认值:0,1,2,3...</span>
<span class="c1">// 注意枚举类型是常量不能赋值，SUN=0;//非法 ，使用的时候直接当成常量使用即可：SUN拿来就用，已经定义过了</span>
<span class="k">enum</span> <span class="nc">Weekday</span> <span class="p">{</span><span class="n">SUN</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">MON</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">TUE</span><span class="p">,</span><span class="n">WED</span><span class="p">,</span><span class="n">THU</span><span class="p">,</span><span class="n">FRI</span><span class="p">,</span><span class="n">SAT</span><span class="p">};</span><span class="c1">// SUN为7，MON为1，以后顺出加1，SAT为6</span>
<span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="n">SUN</span><span class="p">;</span><span class="c1">// 隐含类型转换</span>
<span class="n">Weekday</span> <span class="n">day</span> <span class="o">=</span> <span class="n">Weekday</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 显示类型转换</span>

<span class="c1">// 6.函数参数传递</span>
<span class="c1">// 6.1 值传递:单向传递过程，一旦形参获得值便与实参脱离关系，伺候无论形参发生了怎样的改变，都不会影响到实参</span>
<span class="c1">// 6.2 引用传递:形参相当于实参的别名，一旦形参发生变化，实参也会改变，void swap(int &amp;a,int &amp;b){xxx}</span>
<span class="c1">// 6.3 数组名作为函数参数</span>
<span class="kt">void</span> <span class="nf">rowSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[][</span><span class="mi">2</span><span class="p">],</span><span class="kt">int</span> <span class="n">nRow</span><span class="p">){</span><span class="n">xxx</span><span class="p">}</span> <span class="kt">int</span> <span class="n">table</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">}};</span> <span class="n">rowSum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

<span class="c1">// 7.函数重载:具有相同函数名，但是形参个数或形参类型必须至少一个不同，返回值类型也可不同。但编译器不以返回值来区分函数。</span>

<span class="c1">// 8.c++系统函数 #include&lt;cmath&gt; sqrt/abs/min/max/sin/cos/tan/....</span>

<span class="c1">// 9.结构体 和 c++类唯一区别，类默认成员为private，结构体默认成员 public，因为这个主要是与c兼容</span>
<span class="c1">// 9.1 定义</span>
<span class="k">struct</span> <span class="err">结构体名</span><span class="p">{</span>
    <span class="err">公有成员</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="err">保护型成员</span>
<span class="k">private</span><span class="o">:</span>
    <span class="err">私有成员</span>
<span class="p">}</span><span class="err">；</span>
<span class="c1">// 9.2 声明一个结构体类型。</span>
<span class="k">struct</span> <span class="nc">Student</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">sex</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Student</span> <span class="n">stu</span> <span class="o">=</span> <span class="p">{</span><span class="mi">97001</span><span class="p">,</span><span class="s">&quot;chenyuyang&quot;</span><span class="p">,</span><span class="sc">&#39;F&#39;</span><span class="p">,</span><span class="mi">19</span><span class="p">}</span>

<span class="c1">//9. 联合体，一组数据中任何两个数据不会同时有效,例如一门课程通过或者不通过</span>
<span class="k">union</span> <span class="err">联合体名称</span><span class="p">{</span>
    <span class="err">公有成员</span> <span class="c1">// 默认访问权限</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="err">保护型成员</span>
<span class="k">private</span><span class="o">:</span>
    <span class="err">私有成员</span>
<span class="p">}</span>
<span class="c1">// 举例子</span>
<span class="k">union</span> <span class="nc">Mark</span><span class="p">{</span>
    <span class="kt">char</span> <span class="n">grade</span><span class="p">;</span> <span class="c1">// 等级制的成绩</span>
    <span class="kt">bool</span> <span class="n">pass</span><span class="p">;</span> <span class="c1">// 只记是否通过的成绩</span>
    <span class="kt">int</span> <span class="n">percent</span><span class="p">;</span> <span class="c1">// 百分制的成绩</span>
<span class="p">}</span>

<span class="c1">// 10.预处理命令</span>
<span class="c1">// 10.1宏定义define，宏名一般大写</span>
<span class="c1">// 10.1.1 不带参数的宏定义</span>
<span class="cp">#define LENGTH 10</span>
<span class="cp">#define M y*y+3*y </span><span class="c1">// M代替y*y+3*y使用</span>
<span class="c1">// 10.1.2 带参数宏</span>
<span class="cp">#define M(y) y*y+3*y </span><span class="c1">// k = M(5);</span>
<span class="cp">#define MAX(a,b) (a&gt;b):a:b</span>
<span class="c1">// 10.1.3 取消宏</span>
<span class="cp">#undef LENGTH </span><span class="c1">// 取消宏，后续该宏不可用</span>

<span class="c1">// 10.2 条件编译:用来有选择地对部分程序源代码进行编译</span>
<span class="c1">// 10.2.1 #ifdef 如果标识符被#define命令定义过，则对1进行编译，否则对2进行编译</span>
<span class="cp">#ifdef 标识符</span>
       <span class="err">程序段</span><span class="mi">1</span>
<span class="cp">#else</span>
       <span class="err">程序段</span><span class="mi">2</span>
<span class="cp">#endif</span>
<span class="c1">// 10.2.2 #ifndef，如果标识符未被#define命令定义过，则对1进行编译，否则对2进行编译，和10.2.1相反</span>
<span class="cp">#ifndef 标识符</span>
       <span class="err">程序段</span><span class="mi">1</span>
<span class="cp">#else</span>
       <span class="err">程序段</span><span class="mi">2</span>
<span class="cp">#endif</span>
<span class="c1">// 10.2.3 # if</span>
<span class="cp">#if 常量表达式 </span><span class="c1">// 常量表达式:结果是0/非0</span>
       <span class="err">程序段</span><span class="mi">1</span>
<span class="cp">#else</span>
       <span class="err">程序段</span><span class="mi">2</span>
<span class="cp">#endif</span>

<span class="c1">// 10.3 #error命令，用于调试，在编译中遇到#error指令就停止编译</span>
<span class="cp">#error 出错信息</span><span class="c1">// 出错信息:&quot;XXX has been defined&quot;</span>

<span class="c1">// 11. 基本输入输出</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;string： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">// 流插入运算符 &lt;&lt; 在一个语句中可以多次使用</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span><span class="c1">// 流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据</span>
<span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error message : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//标准错误流: cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出</span>
<span class="n">clog</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error message : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">// 标准日志流:clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</span>

<span class="c1">//编写和执行大型程序时，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</span>

<span class="c1">// 12 new/delete 和 new Type[]/delete[] obj;</span>
<span class="c1">// 12.1 定义</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>     <span class="c1">//allocate an object</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>    <span class="c1">//free an object</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span><span class="p">);</span>     <span class="c1">//allocate an array</span>
<span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>    <span class="c1">//free an array</span>
<span class="c1">// 12.2 语法</span>
<span class="c1">// 12.2.1 变量申请</span>
<span class="n">Type</span><span class="o">*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Type</span><span class="p">;</span>
<span class="p">....</span>
<span class="k">delete</span> <span class="n">pointer</span><span class="p">;</span>
<span class="c1">// 12.2.2 数据申请</span>
<span class="n">Type</span><span class="o">*</span> <span class="n">pointer</span> <span class="k">new</span> <span class="n">Type</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="p">...</span><span class="c1">// pointer是指针，pointer指向的第一个元素可以用pointer[0]/*pointer,第二个元素pointer[1]/*(pointer+1)</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">pointer</span><span class="p">;</span>

<span class="c1">// 13.指针:指针是变量，内容是内存的地址编号</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=&amp;</span><span class="n">a</span><span class="p">;</span><span class="c1">// 定义</span>
<span class="o">*</span><span class="n">p</span> <span class="c1">// 使用:该地址所存储内容,这时其实就是a</span>
<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=&amp;</span><span class="n">i</span><span class="p">;</span><span class="kt">int</span> <span class="o">**</span><span class="n">pp</span><span class="o">=&amp;</span><span class="n">pi</span><span class="p">;</span><span class="c1">// pp是二级指针</span>
<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">40</span><span class="p">;</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span><span class="c1">// 改变一级指针的的指向</span>
<span class="c1">// 13.1 指针和数组:指针是指针变量，数组是指针常量</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="n">a</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span> <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span><span class="c1">// 可以直接赋值</span>
<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">==*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
<span class="c1">// 13.2 const修饰</span>
<span class="c1">// 13.2.1 const修饰指针，const修饰的是p，p为常量，但*p可以赋值</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">p</span><span class="o">=&amp;</span><span class="n">a</span><span class="p">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="n">p</span><span class="o">=&amp;</span><span class="n">b</span><span class="p">;</span><span class="c1">// 指针常量无法修改</span>
<span class="c1">// 13.2.2 const修饰指向，const修饰的是*p,即*p为常量，但p是普通变量，随意赋值</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="o">=&amp;</span><span class="n">a</span><span class="p">;</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="n">p</span><span class="o">=&amp;</span><span class="n">b</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="mi">200</span><span class="p">;</span><span class="c1">// 编译通不过</span>
<span class="c1">// 13.3 函数指针变量</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(){</span><span class="n">xxx</span><span class="p">};</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)()</span> <span class="o">=</span> <span class="n">print</span><span class="p">;</span> <span class="n">pf</span><span class="p">()</span><span class="o">==</span><span class="n">print</span><span class="p">()</span><span class="o">==</span><span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)();</span>
<span class="c1">// 13.4 函数名做参数</span>
<span class="kt">void</span> <span class="nf">xxx</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)){</span><span class="n">xxx</span><span class="p">}</span>
<span class="kt">int</span> <span class="nf">haha</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;}</span>
<span class="n">xxx</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">haha</span><span class="p">);</span>

<span class="c1">// 14. 浅</span>
</code></pre></div>
<p><strong>异常处理</strong></p>
<ul>
<li>throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。</li>
<li>catch: 在想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。</li>
<li>try: try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。它后面通常跟着一个或多个 catch 块。</li>
<li>抛出异常，可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</li>
</ul>
<p><img alt="image-20200212205928600" src="../assets/image-20200212205928600.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 捕获异常</span>
<span class="k">try</span>
<span class="p">{</span>
   <span class="c1">// 保护代码</span>
<span class="p">}</span><span class="k">catch</span><span class="p">(</span> <span class="n">ExceptionName</span> <span class="n">e1</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 能处理任何异常的代码</span>
<span class="p">}</span><span class="k">catch</span><span class="p">(</span> <span class="n">ExceptionName</span> <span class="n">e2</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 能处理任何异常的代码</span>
<span class="p">}</span><span class="k">catch</span><span class="p">(</span> <span class="n">ExceptionName</span> <span class="n">eN</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 能处理任何异常的代码</span>
<span class="p">}</span>


<span class="c1">// 直接抛出异常</span>
<span class="kt">double</span> <span class="n">division</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="k">throw</span> <span class="s">&quot;Division by zero condition!&quot;</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// 人为定义新的异常</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">MyException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">exception</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">what</span> <span class="p">()</span> <span class="k">const</span> <span class="k">throw</span> <span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;C++ Exception&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">try</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="n">MyException</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="n">MyException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MyException caught&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//其他的错误</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_2">类和对象<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// 类的定义</span>
<span class="k">class</span> <span class="nc">Box</span>
<span class="p">{</span>
   <span class="k">public</span><span class="o">:</span> <span class="c1">// 公有成员在程序中类的外部是可访问的</span>

      <span class="c1">// 构造函数:会在每次创建类的新对象时执行,无返回值，名字和类名一样</span>
      <span class="n">Box</span><span class="p">();</span><span class="c1">//无参构造函数声明,不写构造函数时，自动创建</span>
      <span class="n">Box</span><span class="p">(</span><span class="kt">double</span> <span class="n">len</span><span class="p">);</span><span class="c1">// 有参构造函数声明，写了后，不会再自动创建无参构造函数</span>

      <span class="c1">// 拷贝构造函数:形参是本类对象的引用，可加const。作用:一个已存在的对象初始化同类的一个新对象</span>
      <span class="c1">// 如果没有类内声明，系统会自动生成一个隐含的复制构造函数:把初始值对象的每个数据成员的值都复制到新建立的对象中去</span>
      <span class="c1">// 什么时候会使用？</span>
      <span class="c1">// 1. 类的一个对象初始化另一个对象时:Box a(10); Box b(a); Box c=a;//两种用法</span>
      <span class="c1">// 2.函数的形参是类的对象，调用函数‘值’传递时; void f(Box b){} Box c(10); f(c);</span>
      <span class="c1">// 3.函数返回值是类对象时:因为该类对象离开函数就会消亡，所以必须复制构造函数才能返回</span>
      <span class="n">Box</span><span class="p">(</span><span class="k">const</span> <span class="n">Box</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span><span class="c1">// 声明拷贝构造函数</span>

      <span class="c1">// 析构函数:会在每次删除所创建的对象时执行,同类名,无返回值,不接收任何参数，但可以是虚函数</span>
      <span class="o">~</span><span class="n">Box</span><span class="p">();</span><span class="c1">// 析构函数的声明</span>

      <span class="c1">// 成员变量，普通函数/内联函数/常成员函数</span>
      <span class="kt">double</span> <span class="n">length</span><span class="p">;</span><span class="kt">double</span> <span class="n">breadth</span><span class="p">;</span><span class="kt">double</span> <span class="n">height</span><span class="p">;</span>  <span class="c1">// 盒子的长宽高</span>
      <span class="kt">double</span> <span class="nf">getVolume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//普通函数声明，如果直接在类内定义实现，那么称为内联函数，inline可省略</span>
      <span class="kt">double</span> <span class="nf">getVolume</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span><span class="c1">// 重载函数，同名，依据参数类型不同判断，不能仅通过返回类型判断</span>
      <span class="kt">double</span> <span class="nf">get_length</span><span class="p">(){</span><span class="k">return</span> <span class="n">length</span><span class="p">;}</span><span class="c1">// 内联函数/也可以类内声明在类外前面加inline可以定义</span>
      <span class="c1">// 如果一个对象被定义为常对象，那么它只能调用常成员函数，const关键字可以用于重载还是函数的区分  </span>
      <span class="kt">void</span> <span class="nf">print_length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 

      <span class="c1">// 友元函数:1.不是成员函数 2.必须定义在类外部，但有权访问类的所有 私有+保护成员</span>
      <span class="c1">// 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针</span>
      <span class="k">friend</span> <span class="kt">void</span> <span class="n">printWidth</span><span class="p">(</span><span class="n">Box</span> <span class="n">box</span><span class="p">);</span><span class="c1">// 声明友元函数</span>

      <span class="c1">// this指针:this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</span>
      <span class="kt">double</span> <span class="nf">thisGetVolume</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span><span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getVolume</span><span class="p">();}</span>

      <span class="c1">// 静态成员:在类的所有对象中是共享的,意味着无论创建多少个类的对象，静态成员都只有一个副本</span>
      <span class="k">static</span> <span class="kt">int</span> <span class="n">objectCount</span><span class="p">;</span>
      <span class="c1">// 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符::就可以访问</span>
      <span class="c1">// 静态成员函数没有this指针，并且只能访问静态成员(静态成员变量+静态成员函数)</span>
      <span class="k">static</span> <span class="kt">int</span> <span class="n">getObjectCount</span><span class="p">();</span>

      <span class="c1">// 重载运算符:函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表，可重载运算符见下图，下面是 重载 + 运算符，用于把两个 Box 对象相加</span>
      <span class="n">Box</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Box</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">Box</span> <span class="n">box</span><span class="p">;</span>
         <span class="n">box</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
         <span class="n">box</span><span class="p">.</span><span class="n">breadth</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">breadth</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">breadth</span><span class="p">;</span>
         <span class="n">box</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
         <span class="k">return</span> <span class="n">box</span><span class="p">;</span>
      <span class="p">}</span>


  <span class="k">private</span><span class="o">:</span><span class="c1">//私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。如果没有使用任何访问修饰符，类的成员默认为私有成员</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">const_a</span><span class="p">;</span> <span class="c1">// 常数据成员，只能通过初始化列表来获得初值</span>
      <span class="kt">double</span> <span class="n">width</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">lenght</span><span class="p">;</span>
      <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">protected</span><span class="o">:</span><span class="c1">// 保护成员类似私有成员，但保护成员在派生类（即子类）中是可访问的。</span>
<span class="p">};</span>
<span class="c1">//一般都是类内声明函数，类的外部使用范围解析运算符 :: 定义该函数</span>
<span class="c1">// 定义构造函数</span>
<span class="n">Box</span><span class="o">::</span><span class="n">Box</span><span class="p">(</span><span class="kt">void</span><span class="p">){...}</span>
<span class="n">Box</span><span class="o">::</span><span class="n">Box</span><span class="p">(</span><span class="kt">double</span> <span class="n">len</span><span class="p">){...}</span>
<span class="n">Box</span><span class="o">::</span><span class="n">Box</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="n">const_a</span><span class="p">(</span><span class="n">i</span><span class="p">){...}</span> <span class="c1">// 常数据成员，只能通过初始化列表来获得初值</span>
<span class="c1">// 定义拷贝构造函数</span>
<span class="n">Box</span><span class="o">::</span><span class="n">Box</span><span class="p">(</span><span class="k">const</span> <span class="n">Box</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">){</span><span class="n">ptr</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">;</span><span class="o">*</span><span class="n">ptr</span><span class="o">=*</span><span class="n">obj</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span><span class="c1">// 拷贝值}</span>
<span class="c1">// 定义析构函数</span>
<span class="n">Box</span><span class="o">::~</span><span class="n">Line</span><span class="p">(</span><span class="kt">void</span><span class="p">){...}</span>
<span class="c1">// 定义带返回值的成员函数---》返回值类型 类名::函数成员名(参数表){函数体}</span>
<span class="kt">double</span> <span class="n">Box</span><span class="o">::</span><span class="n">getVolume</span><span class="p">(</span><span class="kt">void</span><span class="p">){...}</span>
<span class="kt">double</span> <span class="n">Box</span><span class="o">::</span><span class="n">getVolume</span><span class="p">(</span><span class="kt">void</span><span class="p">){...}</span>
<span class="c1">// 定义常成员函数,调用 const Box b(10); b.print_length();</span>
<span class="kt">void</span> <span class="n">Box</span><span class="o">::</span><span class="n">print_length</span><span class="p">(){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">length</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>                        
<span class="c1">// 友元函数定义,虽然声明在类内部，但并不是类成员函数，是独立存在的，所以不需要使用解析运算符::</span>
<span class="kt">void</span> <span class="n">printWidth</span><span class="p">(</span><span class="n">Box</span> <span class="n">box</span><span class="p">){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">box</span><span class="p">.</span><span class="n">width</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span><span class="c1">// 注意，这里访问了类的私有变量:width</span>
<span class="c1">// 初始化类 Box 的静态成员</span>
<span class="kt">int</span> <span class="n">Box</span><span class="o">::</span><span class="n">objectCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


<span class="c1">// 类的声明</span>
<span class="n">Box</span> <span class="n">box1</span><span class="p">;</span>
<span class="n">Box</span> <span class="n">box2</span> <span class="o">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">parameters</span><span class="p">);</span>
<span class="n">Box</span> <span class="nf">box3</span><span class="p">(</span><span class="n">parameters</span><span class="p">);</span>
<span class="n">Box</span><span class="o">*</span> <span class="n">box4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="p">(</span><span class="n">parameters</span><span class="p">);</span>

<span class="c1">//访问类的成员</span>
<span class="n">box1</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">box1</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<p><img alt="image-20200212202915014" src="../assets/image-20200212202915014.png" /></p>
<p><img alt="image-20200212202951235" src="../assets/image-20200212202951235.png" /></p>
<p><strong>前向引用申明</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 懵逼了吧，此时咋调用？</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">;</span><span class="c1">// 前向引用声明即可</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>多文件结构</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// point.h</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Point</span><span class="p">();</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">){}</span>
    <span class="n">Point</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Point</span><span class="p">(){</span><span class="n">count</span><span class="o">--</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">getY</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">y</span><span class="p">;}</span>
    <span class="k">static</span> <span class="kt">void</span>  <span class="n">showCount</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">// Point.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;point.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">Point</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//使用类名初始化静态数据成员</span>

<span class="n">Point</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="o">:</span><span class="n">x</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">){</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Point</span><span class="o">::</span><span class="n">showCount</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Object count=&quot;</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;point.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Point</span> <span class="n">a</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Point A:&quot;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">.</span><span class="n">getY</span><span class="p">();</span>
    <span class="n">Point</span><span class="o">::</span><span class="n">showCount</span><span class="p">();</span>

    <span class="n">Point</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Point B:&quot;</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="p">.</span><span class="n">getY</span><span class="p">();</span>
    <span class="n">Point</span><span class="o">::</span><span class="n">showCount</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>继承</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="err">派生类名</span><span class="o">:</span><span class="err">继承方式</span> <span class="err">基类名</span><span class="mi">1</span><span class="err">，继承方式</span> <span class="err">基类名</span><span class="mf">2.</span><span class="p">..{}</span>
<span class="c1">// 基类 Shape</span>
<span class="k">class</span> <span class="nc">Shape</span> 
<span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">w</span><span class="p">){</span><span class="n">width</span> <span class="o">=</span> <span class="n">w</span><span class="p">;}</span>
      <span class="kt">void</span> <span class="n">setHeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">){</span><span class="n">height</span> <span class="o">=</span> <span class="n">h</span><span class="p">;}</span>
   <span class="k">protected</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 基类 PaintCost</span>
<span class="k">class</span> <span class="nc">PaintCost</span> 
<span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">getCost</span><span class="p">(</span><span class="kt">int</span> <span class="n">area</span><span class="p">){</span><span class="k">return</span> <span class="n">area</span> <span class="o">*</span> <span class="mi">70</span><span class="p">;}</span>
<span class="p">};</span>
<span class="c1">// 派生类</span>
<span class="k">class</span> <span class="nc">Rectangle</span><span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">,</span> <span class="k">public</span> <span class="n">PaintCost</span>
<span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">getArea</span><span class="p">(){</span><span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);}</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>注意事项</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 1. 如果派生类声明了一个和某基类成员同名的新成员(参数表也相同，否则为重载)，派生类新成员隐藏了外层同名成员</span>

<span class="c1">// 2. 派生类可以访问基类中所有的非私有成员，同时，一个派生类继承了所有的基类方法，但下列情况除外：</span>
    <span class="c1">// 2.1.基类的构造函数、析构函数和拷贝构造函数。</span>
    <span class="c1">// 2.2.基类的重载运算符。</span>
    <span class="c1">// 2.3.基类的友元函数</span>

<span class="c1">// 3.访问控制</span>
<span class="c1">// 3.1 public，公有继承:基类的public能直接访问，protected修饰的类内能访问类外对象不能访问，但private修饰的不可直接访问</span>
<span class="c1">// 3.2 private,私有继承：基类的public和protected修饰的以私有成员身份出现在派生类中，private修饰的不可直接访问</span>
<span class="c1">// 3.3 protected，保护继承：基类的public和protected修饰的以保护成员身份出现在派生类中但是类外派生类对象无法直接访问他们，private修饰的不可直接访问</span>

<span class="c1">// 4.派生类的构造函数和析构函数 必须对基类的构造函数和析构函数进行初始化，因为构造函数和析构函数并没有被继承</span>
<span class="c1">// 4.1 构造函数,对于使用默认构造函数的基类，可以不给出类名，对于成员对象也类似</span>
<span class="err">派生类名</span><span class="o">::</span><span class="err">派生类名</span><span class="p">(</span><span class="err">参数表</span><span class="p">)</span><span class="o">:</span><span class="err">基类名</span><span class="mi">1</span><span class="p">(</span><span class="err">基类</span><span class="mi">1</span><span class="err">初始化参数表</span><span class="p">),...,</span><span class="err">基类名</span><span class="n">n</span><span class="p">(</span><span class="err">基类</span><span class="n">n初始化参数表</span><span class="p">),</span><span class="err">成员对象名</span><span class="mi">1</span><span class="p">(</span><span class="err">成员对象</span><span class="mi">1</span><span class="err">初始化参数表</span><span class="p">),...,</span><span class="err">成员对象名</span><span class="n">m</span><span class="p">(</span><span class="err">成员对象</span><span class="n">m初始化参数表</span><span class="p">){</span><span class="n">xxx</span><span class="p">}</span>
<span class="k">class</span> <span class="nc">Base1</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Constrtucting Base1&quot;</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Base2</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base2</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Constrtucting Base2&quot;</span><span class="o">&lt;&lt;</span><span class="n">j</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Base3</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base3</span><span class="p">(){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Constrtucting Base3*&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span>
<span class="p">};</span>
<span class="c1">// 基类构造函数的‘调用’顺序是按照派生类定义时的顺序，因此应该是先Base2，再Base1,最后Base3</span>
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span><span class="k">public</span> <span class="n">Base2</span><span class="p">,</span><span class="k">public</span> <span class="n">Base1</span><span class="p">,</span><span class="k">public</span> <span class="n">Base3</span><span class="p">{</span> <span class="c1">// 注意基类名的顺序，依次为基准</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 注意基类名的个数和顺序，注意成员对象名的个数和顺序，这里Base3是默认构造函数，无需传参，定义顺序随意</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">Base1</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">member2</span><span class="p">(</span><span class="n">d</span><span class="p">),</span><span class="n">member1</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">Base2</span><span class="p">(</span><span class="n">b</span><span class="p">){}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Base1</span> <span class="n">member1</span><span class="p">;</span>
    <span class="n">Base2</span> <span class="n">member2</span><span class="p">;</span>
    <span class="n">Base3</span> <span class="n">member3</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 4.2复制构造函数</span>
<span class="n">Derived</span><span class="o">::</span><span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="o">:</span><span class="n">Base</span><span class="p">(</span><span class="n">v</span><span class="p">)(...)</span><span class="c1">// 可以用派生类的对象去初始化基类的引用</span>
<span class="c1">// 4.3析构函数，无参数所以无需写，只不过释放顺序刚好和构造函数顺序相反</span>

<span class="c1">// 5.多继承重名问题，虚基类解决：Base基类，Base1和Base2继承自Base类，Base3继承自Base1和Base2,那么Base1和Base2中会有很多同名函数，那Base3中怎么访问？方法一:每个方法名可以用作用域区分(Base1::fun/Base2::fun)。方法二：把Base类设置为虚基类，此时Base1/Base2中所有同名函数只有一个映射</span>
<span class="c1">// 5.1虚基类声明</span>
<span class="k">class</span> <span class="err">派生类名</span><span class="o">:</span><span class="k">virtual</span> <span class="err">继承方式</span> <span class="err">基类名</span><span class="p">{</span><span class="n">xxx</span><span class="p">}</span> <span class="c1">// Base3访问的同名函数是直接访问Base类函数/数据成员</span>
<span class="c1">// 5.2 虚基类的构造函数</span>
<span class="k">class</span> <span class="nc">Base0</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base0</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span><span class="n">var0</span><span class="p">(</span><span class="n">var</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">var0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Base1</span><span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">Base0</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base1</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span><span class="n">Base0</span><span class="p">(</span><span class="n">var</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">var1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Base2</span><span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">Base0</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Base2</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span><span class="n">Base0</span><span class="p">(</span><span class="n">var</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">var2</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span><span class="k">public</span> <span class="n">Base1</span><span class="p">,</span><span class="k">public</span> <span class="n">Base2</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span><span class="o">:</span><span class="n">Base0</span><span class="p">(</span><span class="n">var</span><span class="p">),</span><span class="n">Base1</span><span class="p">(</span><span class="n">var</span><span class="p">),</span><span class="n">Base2</span><span class="p">(</span><span class="n">var</span><span class="p">){}</span> <span class="c1">// 虚基类三次初始化？完全可以这样写</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>多态</strong></p>
<p><strong>虚函数**是在**基类**中使用关键字 **virtual 声明的函数</strong>。在派生类中重新定义基类中**定义的虚函数时，会告诉编译器不要静态链接到该函数。<strong>我们想要的是**在程序中任意点可以根据所调用的对象类型来选择调用的函数</strong>，这种操作被称为**动态链接**，或后期绑定。
 若在基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数，在函数参数后直接加 = 0 告诉编译器，函数没有主体，这种虚函数即是纯虚函数。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
   <span class="k">protected</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="c1">// 构造函数</span>
      <span class="n">Shape</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">width</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
         <span class="n">height</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 虚函数</span>
      <span class="k">virtual</span> <span class="kt">int</span> <span class="n">area</span><span class="p">()</span>
      <span class="p">{</span>
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Parent class area :&quot;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
         <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// 纯虚函数，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。</span>
      <span class="c1">// 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。</span>
      <span class="k">virtual</span> <span class="kt">int</span> <span class="n">area</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 继承</span>
<span class="k">class</span> <span class="nc">Rectangle</span><span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="c1">// 派生类的构造函数实现时，因为基类写了需要传参的构造函数，所以在构造时直接传入基类需的参数</span>
      <span class="n">Rectangle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">Shape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
      <span class="c1">// 实现基类的虚函数，这样就实现了多态:意味着调用成员函数时会根据调用函数的对象的类型来执行不同的函数</span>
      <span class="kt">int</span> <span class="n">area</span> <span class="p">(){</span> 
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Rectangle class area :&quot;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
         <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span> 
      <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Triangle</span><span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span><span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
      <span class="n">Triangle</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">Shape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
      <span class="kt">int</span> <span class="n">area</span> <span class="p">(){</span> 
         <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Triangle class area :&quot;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
         <span class="k">return</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> 
      <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 程序的主函数</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">Shape</span> <span class="o">*</span><span class="n">shape</span><span class="p">;</span>
   <span class="n">Rectangle</span> <span class="n">rec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
   <span class="n">Triangle</span>  <span class="n">tri</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>

   <span class="c1">// 存储矩形的地址</span>
   <span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rec</span><span class="p">;</span>
   <span class="c1">// 调用矩形的求面积函数 area</span>
   <span class="n">shape</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span>  <span class="c1">//Rectangle class area</span>
   <span class="c1">// 存储三角形的地址</span>
   <span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tri</span><span class="p">;</span>
   <span class="c1">// 调用三角形的求面积函数 area</span>
   <span class="n">shape</span><span class="o">-&gt;</span><span class="n">area</span><span class="p">();</span>  <span class="c1">//Triangle class area</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_3">模板<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 一般格式</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">type</span><span class="o">&gt;</span> <span class="c1">// template &lt;typename T&gt;</span>
<span class="k">return</span><span class="o">-</span><span class="n">type</span> <span class="n">func</span><span class="o">-</span><span class="n">name</span><span class="p">(</span><span class="n">parameter</span> <span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// 函数的主体</span>
<span class="p">}</span>
<span class="c1">// 举例说明</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//使用const&amp;可节省传递时间，同时保证值不被改变</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">Max</span> <span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">b</span><span class="p">:</span><span class="n">a</span><span class="p">;</span> 
<span class="p">}</span> 
<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Max(i, j): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

    <span class="kt">double</span> <span class="n">f1</span> <span class="o">=</span> <span class="mf">13.5</span><span class="p">;</span> 
    <span class="kt">double</span> <span class="n">f2</span> <span class="o">=</span> <span class="mf">20.7</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Max(f1, f2): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

    <span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span> 
    <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">&quot;World&quot;</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Max(s1, s2): &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 类模板</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">type</span><span class="o">&gt;</span> 
<span class="k">class</span> <span class="nc">class</span><span class="o">-</span><span class="n">name</span> <span class="p">{</span>
     <span class="c1">//类的主体</span>
<span class="p">}</span>
<span class="c1">// 举例子</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span> 
  <span class="k">private</span><span class="o">:</span> 
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>     <span class="c1">// 元素 </span>

  <span class="k">public</span><span class="o">:</span> 
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// 入栈</span>
    <span class="kt">void</span> <span class="nf">pop</span><span class="p">();</span>               <span class="c1">// 出栈</span>
    <span class="n">T</span> <span class="nf">top</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>            <span class="c1">// 返回栈顶元素</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>       <span class="c1">// 如果为空则返回真。</span>
        <span class="k">return</span> <span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> 
    <span class="p">}</span> 
<span class="p">};</span> 

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push</span> <span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="c1">// 追加传入元素的副本</span>
    <span class="n">elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>    
<span class="p">}</span> 

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop</span> <span class="p">()</span> 
<span class="p">{</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> 
        <span class="k">throw</span> <span class="nf">out_of_range</span><span class="p">(</span><span class="s">&quot;Stack&lt;&gt;::pop()</span><span class="o">:</span> <span class="n">empty</span> <span class="n">stack</span><span class="s">&quot;)</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="c1">// 删除最后一个元素</span>
    <span class="n">elems</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>         
<span class="p">}</span> 

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">top</span> <span class="p">()</span> <span class="k">const</span> 
<span class="p">{</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">elems</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> 
        <span class="k">throw</span> <span class="nf">out_of_range</span><span class="p">(</span><span class="s">&quot;Stack&lt;&gt;::top()</span><span class="o">:</span> <span class="n">empty</span> <span class="n">stack</span><span class="s">&quot;)</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="c1">// 返回最后一个元素的副本 </span>
    <span class="k">return</span> <span class="n">elems</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>      
<span class="p">}</span> 

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> 
<span class="p">{</span> 
    <span class="k">try</span> <span class="p">{</span> 
        <span class="n">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>         <span class="n">intStack</span><span class="p">;</span>  <span class="c1">// int 类型的栈 </span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">stringStack</span><span class="p">;</span>    <span class="c1">// string 类型的栈 </span>

        <span class="c1">// 操作 int 类型的栈 </span>
        <span class="n">intStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> 
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intStack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 

        <span class="c1">// 操作 string 类型的栈 </span>
        <span class="n">stringStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span> 
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stringStack</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
        <span class="n">stringStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
        <span class="n">stringStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
    <span class="p">}</span> 
    <span class="k">catch</span> <span class="p">(</span><span class="n">exception</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exception: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div>
<h3 id="stl">STL标准模板库<a class="headerlink" href="#stl" title="Permanent link">&para;</a></h3>
<p>STL中包括六大组件：容器、迭代器、算法、仿函数、迭代适配器、空间配置器。</p>
<ul>
<li>STL中的常用容器包括：序列式容器（vector、deque、list）</li>
<li>关联式容器（map、set）</li>
<li>容器适配器（queue、stack）。</li>
</ul>
<p><strong>STL库常用函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 0.一种循环的简单用法c++11</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">i</span><span class="p">:</span><span class="n">a</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&quot; &quot;</span><span class="p">;</span>

<span class="c1">// 0.1 for_each()：Function for_each(InputIterator beg, InputIterator end, Function f)</span>
<span class="c1">// for_each() 可以理解为python的map操作，更加复杂的可以使用transform函数</span>

<span class="c1">// 1.abs的区别</span>
<span class="n">abs</span><span class="p">();</span> <span class="c1">// 主要是对int求绝对值,包含在&lt;stdlib.h&gt;</span>
<span class="n">fabs</span><span class="p">();</span> <span class="c1">// 对float，double求绝对值 包含在&lt;cmath&gt;</span>

<span class="c1">// 1.1 sort排序 #include&lt;algorithm&gt;</span>
<span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">)</span>
<span class="o">*</span> <span class="n">first</span><span class="err">：是要排序的数组的起始地址</span>
<span class="o">*</span> <span class="n">last</span><span class="err">：是结束的地址（最后一个数据的后一个数据的地址）</span>
<span class="o">*</span> <span class="n">comp是排序的方法</span><span class="err">：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是从小到大排序。</span>
<span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">// 升序排列</span>
<span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span><span class="c1">// 数组排序</span>
<span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">bool</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;});</span><span class="c1">// 降序</span>

<span class="c1">// 1.2 max_element() 与 min_element()：#include&lt;algorithm&gt;，返回区间 [first,last)中第一个最大值和第一个最小值对应的迭代器。（可以理解为找最大值或最小值的索引）</span>
<span class="n">ForwardIt</span> <span class="nf">min_element</span><span class="p">(</span><span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">[,</span><span class="n">cmp</span><span class="p">]);</span><span class="c1">//指向范围 [first, last) 中最大元素的迭代器。若范围中有多个元素等价于最大元素，则返回指向首个这种元素的迭代器。若范围为空则返回 last </span>
<span class="n">ForwardIt</span> <span class="nf">max_element</span><span class="p">(</span><span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">[,</span><span class="n">cmp</span><span class="p">]);</span>
<span class="c1">// 举例子，数组</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">max_element</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">// 输出最大值索引</span>
<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">max_element</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出最大值</span>
<span class="c1">// 举例子，vector</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">max_element</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">// 输出最大值索引</span>
<span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">max_element</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出最大值</span>

<span class="c1">// 1.3 accumulate #include&lt;numeric&gt;：作用有两个，一个是累加求和，另一个是自定义类型数据的处理</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">// 第三个形参则是累加的初值</span>
<span class="n">string</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">));</span><span class="c1">//从空字符串开始，把vec里的每个元素连接成一个字符串</span>

<span class="c1">// 2.distance的作用</span>
<span class="cp">#include</span><span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="n">distance</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span><span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span><span class="c1">// 该函数用于计算两个迭代器表示的范围内包含元素的个数:[first,last),举例:std::distance(v.begin(),v.end())</span>

<span class="c1">// 3.unique：删除相邻的重复元素，所以一般是排序后使用</span>
<span class="n">iterator</span> <span class="nf">unique</span><span class="p">(</span><span class="n">iterator</span> <span class="n">it_1</span><span class="p">,</span><span class="n">iterator</span> <span class="n">it_2</span><span class="p">);</span><span class="c1">// 对[it_1,it_2)范围内的元素进行去重，返回值是一个迭代器:去重后容器中不重复序列的最后一个元素的下一个元素。注:单纯的使用unique函数的话，容器的长度并没有发生变化，只是元素的位置发生了变化</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
<span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">// {1 3 4 5 6 7 6 7 },不重复的元素都移到了前面，后面元素没改变，惊讶！！！</span>
<span class="c1">// 如果想删除元素，不保留后面元素如何做？</span>
<span class="n">new_end</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">// 注意返回值，上面有解释</span>
<span class="n">data</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">new_end</span><span class="p">,</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">// 删除后面的元素即可</span>

<span class="c1">//4.transform,op：就是函数名，这个函数类似于python的map操作,为保证元素个数相等，fir.resize(res.size)</span>
<span class="c1">// 当然，如果是简单的操作可以使用 for_each代替</span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="c1">// 一元操作：将op应用于[first1, last1)范围内的每个元素，并将每个操作返回的值存储在以result开头的范围内，当然，这个result可以是first.begin(),即执行replace操作</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">OutputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">UnaryOperation</span><span class="o">&gt;</span>
  <span class="n">OutputIterator</span> <span class="n">transform</span> <span class="p">(</span><span class="n">InputIterator</span> <span class="n">first1</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last1</span><span class="p">,</span>
                            <span class="n">OutputIterator</span> <span class="n">result</span><span class="p">,</span> <span class="n">UnaryOperation</span> <span class="n">op</span><span class="p">);</span>
<span class="c1">// 二元操作:使用[first1, last1)范围内的每个元素作为第一个参数调用binary_op,并以first2开头的范围内的每个元素（元素个数必须和1相同）作为第二个参数调用binary_op,每次调用返回的值都存储在以result开头的范围内。</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">InputIterator2</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">OutputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">BinaryOperation</span><span class="o">&gt;</span>
  <span class="n">OutputIterator</span> <span class="n">transform</span> <span class="p">(</span><span class="n">InputIterator1</span> <span class="n">first1</span><span class="p">,</span> <span class="n">InputIterator1</span> <span class="n">last1</span><span class="p">,</span>
                            <span class="n">InputIterator2</span> <span class="n">first2</span><span class="p">,</span> <span class="n">OutputIterator</span> <span class="n">result</span><span class="p">,</span>
                            <span class="n">BinaryOperation</span> <span class="n">binary_op</span><span class="p">);</span>

<span class="c1">// 6.二分查找 Binary_search/lower_bound/upper_bound:该函数仅适用于“已排好序”的序列：并不是严格的降序活升序，只要满足“所有令 element&lt;val（或者 comp(val, element）成立的元素都位于不成立元素的前面（其中 element 为指定范围内的元素）”即可。</span>
<span class="c1">// 6.1 Binary search：用于在指定区域内查找是否包含目标值。</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="c1">//查找 [first, last) 区域内是否包含 val</span>
<span class="kt">bool</span> <span class="nf">binary_search</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
<span class="c1">//根据 comp 指定的规则，查找 [first, last) 区域内是否包含 val,comp:此参数可接收一个包含 2 个形参（第一个形参值为 val）且返回值为 bool 类型的函数，可以是普通函数，也可以是函数对象。</span>
<span class="kt">bool</span> <span class="nf">binary_search</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>

<span class="c1">// 6.2 lower_bound():用于在指定区域内查找大于等于目标值的第一个元素。当查找成功时，迭代器指向找到的元素；反之，如果查找失败，迭代器的指向和 last 迭代器相同。</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="c1">//在 [first, last) 区域内查找不小于 val 的元素</span>
<span class="n">ForwardIterator</span> <span class="nf">lower_bound</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
<span class="c1">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素，comp:此参数可接收一个包含 2 个形参（第一个形参值始终为 val）且返回值为 bool 类型的函数，可以是普通函数，也可以是函数对象。</span>
<span class="n">ForwardIterator</span> <span class="nf">lower_bound</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>

<span class="c1">// 6.3 upper_bound：在指定范围内查找大于目标值的第一个元素</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="c1">//查找[first, last)区域中第一个大于 val 的元素。</span>
<span class="n">ForwardIterator</span> <span class="nf">upper_bound</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span>
<span class="c1">//查找[first, last)区域中第一个不符合 comp 规则的元素，comp:此参数可接收一个包含 2 个形参（第一个形参值为 val）且返回值为 bool 类型的函数，可以是普通函数，也可以是函数对象。</span>
<span class="n">ForwardIterator</span> <span class="nf">upper_bound</span> <span class="p">(</span><span class="n">ForwardIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>
</code></pre></div>
<p><strong>string</strong><a href="https://blog.csdn.net/pengnanzheng/article/details/80549445?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">非常全的总结</a></p>
<div class="highlight"><pre><span></span><code><span class="c1">// #include&lt;string&gt;，常用函数</span>
<span class="c1">// 1.1 初始化</span>
<span class="n">string</span> <span class="n">s1</span><span class="p">;</span><span class="c1">// 空字符串</span>
<span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="sc">&#39;$&#39;</span><span class="p">);</span><span class="c1">// 10个$</span>
<span class="n">string</span> <span class="nf">s3</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
<span class="n">string</span> <span class="nf">s4</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s5</span> <span class="o">=</span> <span class="s">&quot;Hahaha&quot;</span><span class="p">;</span>
<span class="n">s5</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">// 清空</span>

<span class="c1">// string--to--char*</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">charstring</span> <span class="o">=</span> <span class="n">s5</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span><span class="c1">// 使用c_str()进行类型转换时，const关键字是必须的</span>
<span class="c1">// 字符串比较</span>
<span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">==</span><span class="n">s5</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&quot;Hahaha&quot;</span><span class="p">))</span> <span class="p">{...}</span>

<span class="c1">// 1.2 常用简单方法</span>
<span class="kt">int</span> <span class="n">s5</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//当前字符串的大小</span>
<span class="kt">int</span> <span class="n">s5</span><span class="p">.</span><span class="n">length</span><span class="p">();</span><span class="c1">// 当前字符串的长度</span>
<span class="kt">bool</span> <span class="n">s5</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span><span class="c1">// 判断当前字符串是否为空</span>
<span class="kt">void</span> <span class="n">s5</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span><span class="c1">//把字符串当前大小置为len，并用字符c填充不足的部分</span>
<span class="kt">int</span> <span class="n">s5</span><span class="p">.</span><span class="n">capacity</span><span class="p">();</span><span class="c1">// 当前的容量，即string中不必增加内存即可存放的元素个数）</span>
<span class="kt">int</span> <span class="n">s5</span><span class="p">.</span><span class="n">max_size</span><span class="p">();</span><span class="c1">//返回string对象中可存放的最大字符串的长度</span>
<span class="n">s5</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span><span class="c1">// 交换s3和s5的字符串</span>
<span class="n">s5</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">);</span><span class="c1">// 末尾添加一个字符，必须是一个字符</span>
<span class="n">s5</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">);</span><span class="c1">// 末尾添加一个字符串，必须是字符串</span>

<span class="c1">// 判断是否是数字或字母</span>
<span class="cp">#include</span><span class="cpf">&lt;ctype.h&gt;</span><span class="cp"></span>
<span class="n">isdigit</span><span class="p">();</span><span class="c1">// 数字返回非0，非数字返回0；</span>
<span class="n">isalpha</span><span class="p">();</span><span class="c1">// 字母返回非0，非字母返回0；</span>

<span class="c1">// 1.3 insert/erase/replace/empty</span>
<span class="n">str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="c1">// 在str下标为2的位置添加 3个 字符&#39;A&#39;</span>
<span class="n">str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;ABC&quot;</span><span class="p">)</span> <span class="c1">// 在str下标为2的位置添加 字符串 &quot;ABC&quot;</span>
<span class="n">str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 在str下标为2的位置添加 字符串 &quot;ABC&quot; 中 前1个 字符</span>
<span class="n">str</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 在str下标为2的位置添加 字符串 &quot;ABC&quot; 中从位置 1 开始的 1 个字符</span>
<span class="n">str</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 删除 下标2 的位置开始，之后的全删除</span>
<span class="n">str</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 删除 下标2 的位置开始，之后的 1个 删除</span>
<span class="n">str</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1">// 删除 str 所有</span>
<span class="n">str</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;abcd&quot;</span><span class="p">)</span> <span class="c1">// 从 下标2 的位置，替换 4个字节 ，为&quot;abcd&quot;</span>
<span class="c1">// 1.4 find(向后)/rfind(向前)用法相同</span>
<span class="c1">// 返回值是找到的该内容的第一个索引，如果没找到返回 string::npos</span>
<span class="kt">size_t</span> <span class="n">find</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="nf">find</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="nf">find</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="nf">find</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">// 举例子</span>
<span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="c1">// 查找 &#39;A&#39;</span>
<span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 从 位置1 处开始，查找&#39;B&#39;</span>
<span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">)</span> <span class="c1">// 查找 &quot;ABC&quot;</span>
<span class="n">str</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 从 位置1开始查找 &#39;ABC&#39; 的前 2个 字符</span>
<span class="c1">// 1.4.1 查找是否包含有子串中任何一个字符，find_first_of(向后)/find_last_of</span>
<span class="n">str</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">&quot;abBc&quot;</span><span class="p">)</span> <span class="c1">// 查找 &quot;abBc&quot; 和str 相等的任何字符，&quot;abBc&quot; 中有就返回位置</span>
<span class="n">str</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">&quot;abBc&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 查找 &quot;abBc&quot; 和str 相等的任何字符，从 位置1 处，开始查找&quot;abBc&quot; 中的字符，&quot;abBc&quot; 中有的就返回位置</span>
<span class="n">str</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">&quot;abBc&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 查找 &quot;abBc&quot; 和str 相等的任何字符，从 位置1 处，开始查找&quot;abBc&quot; 的前 2个 字符，&quot;abBc&quot; 中有的就返回位置</span>
<span class="c1">// 1.5 子串提取</span>
<span class="n">str1</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 提取子串，提取出 str 的 下标为2 到末尾，给 str1</span>
<span class="n">str1</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// 提取子串，提取出 str 的 下标为2 开始，提取三个字节，给 str1</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s1</span><span class="o">=</span><span class="n">str</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="c1">// 将string类转为字符串数组，返回给s1</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="n">str</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span> <span class="c1">// 将 str 里的 pos 位置开始，拷贝 count个 字符,存到 s 里</span>
</code></pre></div>
<p><strong>vector</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// vector:动态数组，在内存中有连续存储空间，快速随机访问，但插入删除较慢</span>
<span class="c1">//需要包含头文件</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="c1">//1.定义和初始化</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">;</span>    <span class="c1">//默认初始化，vec1为空</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec2</span><span class="p">(</span><span class="n">vec1</span><span class="p">);</span>  <span class="c1">//使用vec1初始化vec2</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec3</span><span class="p">(</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec1</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//使用vec1初始化vec2</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">//10个值为0的元素</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec5</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>  <span class="c1">//10个值为4的元素</span>

<span class="c1">//2.常用操作方法</span>
<span class="c1">//2.1 添加函数</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>            <span class="c1">//尾部添加元素</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">//在vec1[1]处插入5</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//在vec1[1]处插入3个5</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">arr</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="n">arr</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span> <span class="c1">//在vec1[1]处插入数组arr的第三个到第五个数 </span>

<span class="c1">//2.2 删除函数</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>              <span class="c1">//删除末尾元素</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">//删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>                 <span class="c1">//清空元素，元素在内存中并未消失，通常使用swap()来清空</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>        <span class="c1">//利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。</span>

<span class="c1">//2.3 遍历函数</span>
<span class="n">vec1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>        <span class="c1">//取得第一个元素</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">);</span>     <span class="c1">//返回pos位置元素的引用</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>  <span class="c1">//返回首元素的引用</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>  <span class="c1">//返回尾元素的引用</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="o">=</span> <span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">//返回向量头指针，指向第一个元素</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="o">=</span> <span class="n">vec1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  <span class="c1">//返回向量尾指针，指向向量最后一个元素的下一个位置</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">rbegin</span><span class="o">=</span> <span class="n">vec1</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span>  <span class="c1">//反向迭代器，指向最后一个元素</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">rend</span><span class="o">=</span> <span class="n">vec1</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span>  <span class="c1">//反向迭代器，指向第一个元素之前的位置</span>
<span class="k">for</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">vec1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">&lt;</span><span class="n">vec1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// vector中的find，vector没有find函数，但是可以使用algorithm中的find代替</span>
<span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">value</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">//2.4 判断函数</span>
<span class="kt">bool</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="n">vec1</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>    <span class="c1">//判断是否为空</span>

<span class="c1">//2.5 大小函数</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">vec1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  <span class="c1">//元素个数</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">capacity</span><span class="p">();</span>  <span class="c1">//返回容器当前能够容纳的元素个数</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">max_size</span><span class="p">();</span>  <span class="c1">//返回容器最大的可能存储的元素个数</span>

<span class="c1">//2.6 改动函数</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">//赋n个值为x的元素到vec1中，这会清除掉vec1中以前的内容。</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span><span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span>  <span class="c1">//当前向量中[first,last)中元素设置成迭代器所指向量的元素，这会清除掉vec1中以前的内容。</span>
</code></pre></div>
<p><strong>queue &amp; stack &amp; deque</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// ①queque</span>
<span class="cp">#include</span><span class="cpf">&lt;queue&gt;</span><span class="c1"> // queue&lt;类型,[容器类型]&gt;</span><span class="cp"></span>
<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="c1">// 将x接到队列的末端</span>
<span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">// 队列中的元素个数</span>
<span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span><span class="c1">// 队列是否为空</span>
<span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="c1">// 返回第一个元素</span>
<span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="c1">// 返回最后一个元素</span>
<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="c1">// void,弹出队列的第一个元素</span>

<span class="c1">// ②stack</span>
<span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp"></span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sta</span><span class="p">;</span>
<span class="n">sta</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 在栈顶增加元素</span>
<span class="n">sta</span><span class="p">.</span><span class="n">top</span><span class="p">();</span><span class="c1">// 返回栈顶元素</span>
<span class="n">sta</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="c1">// 移除栈顶元素</span>
<span class="n">sta</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 返回栈中元素数目</span>
<span class="n">sta</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// 堆栈为空则返回真</span>

<span class="c1">// ③deque:双向队列不论在尾部或头部插入元素速度较快，中间插入元素速度较慢</span>
<span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="c1">  // 头文件 </span><span class="cp"></span>

<span class="c1">//1.声明和初始化</span>
<span class="n">deque</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">;</span>  <span class="c1">// 声明一个元素类型为type的双端队列que</span>
<span class="n">deque</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>  <span class="c1">// 声明一个类型为type、含有size个默认值初始化元素的的双端队列que</span>
<span class="n">deque</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>  <span class="c1">// 声明一个元素类型为type、含有size个value元素的双端队列que</span>
<span class="n">deque</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">(</span><span class="n">mydeque</span><span class="p">);</span>  <span class="c1">// deq是mydeque的一个副本</span>
<span class="n">deque</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">deq</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>  <span class="c1">// 使用迭代器first、last范围内的元素初始化deq</span>

<span class="c1">//2.常用成员函数</span>
<span class="n">deq</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>  <span class="c1">//用来访问双向队列中单个的元素。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>  <span class="c1">//用来访问双向队列中单个的元素。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>  <span class="c1">//返回第一个元素的引用。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>  <span class="c1">//返回最后一个元素的引用。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="c1">//把元素x插入到双向队列的头部。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="c1">//把元素x插入到双向队列的尾部。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>  <span class="c1">//弹出双向队列的第一个元素。</span>
<span class="n">deq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>  <span class="c1">//弹出双向队列的最后一个元素。</span>
</code></pre></div>
<p><strong>list</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// list:双向链表，快速的插入和删除，但是随机访问却比较慢</span>
<span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp"></span>

<span class="c1">//1.定义和初始化</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">lst1</span><span class="p">;</span>          <span class="c1">//创建空list</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>       <span class="c1">//创建含有5个元素的list</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">lst3</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>  <span class="c1">//创建含有3个元素值为2的list</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">lst4</span><span class="p">(</span><span class="n">lst2</span><span class="p">);</span>    <span class="c1">//使用lst2初始化lst4</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">lst5</span><span class="p">(</span><span class="n">lst2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">lst2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">//同lst4</span>

<span class="c1">//2.常用操作函数</span>
<span class="n">lst1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">lst2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">lst2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>  <span class="c1">//给list赋值为lst2</span>
<span class="n">lst1</span><span class="p">.</span><span class="n">back</span><span class="p">();</span> <span class="c1">//返回最后一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">//返回指向第一个元素的迭代器 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>  <span class="c1">//删除所有元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>  <span class="c1">//如果list是空的则返回true </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  <span class="c1">//返回末尾的迭代器 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">erase</span><span class="p">();</span>  <span class="c1">//删除一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>  <span class="c1">//返回第一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">insert</span><span class="p">();</span>  <span class="c1">//插入一个元素到list中 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">max_size</span><span class="p">();</span>  <span class="c1">//返回list能容纳的最大元素数量 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">merge</span><span class="p">();</span>  <span class="c1">//合并两个list </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>  <span class="c1">//删除最后一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>  <span class="c1">//删除第一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">push_back</span><span class="p">();</span>  <span class="c1">//在list的末尾添加一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">push_front</span><span class="p">();</span>  <span class="c1">//在list的头部添加一个元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span>  <span class="c1">//返回指向第一个元素的逆向迭代器 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">remove</span><span class="p">();</span>  <span class="c1">//从list删除元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">remove_if</span><span class="p">();</span>  <span class="c1">//按指定条件删除元素 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span>  <span class="c1">//指向list末尾的逆向迭代器 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">resize</span><span class="p">();</span>  <span class="c1">//改变list的大小 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span>  <span class="c1">//把list的元素倒转 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  <span class="c1">//返回list中的元素个数 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span>  <span class="c1">//给list排序 </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">splice</span><span class="p">();</span>  <span class="c1">//合并两个list </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">swap</span><span class="p">();</span>  <span class="c1">//交换两个list </span>
<span class="n">lst1</span><span class="p">.</span><span class="n">unique</span><span class="p">();</span>  <span class="c1">//删除list中相邻重复的元素</span>
</code></pre></div>
<p><strong>map</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// map:一种键值对容器.map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的且唯一的。</span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="c1">//1.定义与初始化</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">ID_Name</span><span class="p">;</span>
<span class="c1">// 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">ID_Name</span> <span class="o">=</span> <span class="p">{{</span> <span class="mi">2015</span><span class="p">,</span> <span class="s">&quot;Jim&quot;</span> <span class="p">},{</span> <span class="mi">2016</span><span class="p">,</span> <span class="s">&quot;Tom&quot;</span> <span class="p">},{</span> <span class="mi">2017</span><span class="p">,</span> <span class="s">&quot;Bob&quot;</span><span class="p">}};</span>

<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">map1</span><span class="p">;</span>
<span class="c1">// 2.属性</span>
<span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">map1</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>             <span class="c1">//取得key</span>
<span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map1</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>       <span class="c1">//取得value</span>
<span class="c1">// 3.基本操作函数</span>
<span class="n">map1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="c1">// 指向起始</span>
<span class="n">map1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="c1">// 指向末尾</span>
<span class="n">map1</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span><span class="c1">// 指向末尾</span>
<span class="n">map1</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span><span class="c1">// 指向起始</span>
<span class="n">map1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">// 返回容器大小</span>
<span class="n">map1</span><span class="p">.</span><span class="n">max_size</span><span class="p">();</span><span class="c1">// 计算map容器的最大长度</span>
<span class="n">map1</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span><span class="c1">// 判断容器是否为空</span>
<span class="n">map1</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span><span class="c1">// 返回key所在位置的迭代器，key不存在返回map1.end();</span>
<span class="c1">// if(map1.find(k) != map1.end()) { ... }</span>
<span class="n">map1</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="c1">// 返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素，所以返回值只能是1或0。</span>
<span class="n">map1</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">// 删除所有元素</span>

<span class="c1">// 3.1 insert插入元素</span>
<span class="n">map1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="s">&quot;hello&quot;</span><span class="p">));</span><span class="c1">// 直接插入键值对</span>
<span class="n">map1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="s">&quot;hello&quot;</span><span class="p">));</span><span class="c1">// 通过迭代器指定位置插入</span>

<span class="c1">// 3.2 删除元素</span>
<span class="n">map1</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="c1">// 通过key删除</span>
<span class="n">map1</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">map1</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key1</span><span class="p">));</span><span class="c1">// 通过迭代器删除某值</span>
<span class="n">map1</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">map1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">map1</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">// 通过迭代器删除 == map1.clear()</span>

<span class="c1">// for_each()遍历map，注意lambda参数要写成pair类型，因为map返回的是一对数据，是pair类型的</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">map1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">map1</span><span class="p">.</span><span class="n">end</span><span class="p">(),[](</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">){</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;})</span>
</code></pre></div>
<p><strong>set</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// set：set的含义是集合，它是一个有序的容器，无重复元素</span>
<span class="c1">// 里面的元素都是排序好的支持插入、删除、查找等操作，就像一个集合一样，所有的操作都是严格在logn时间内完成，效率非常高，使用方法类似list。</span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="c1">// 插入数值到集合，如有重复元素，则自动排重,返回值是pair&lt;set&lt;int&gt;::iterator,bool&gt;，bool标志着插入是否成功，而iterator代表插入的位置，若key_value已经在set中，则iterator表示的key_value在set中的位置。</span>
     <span class="n">pair</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">pr</span><span class="p">;</span>
     <span class="n">pr</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">second</span><span class="p">);</span><span class="c1">// 将定位器first到second之间的元素插入到set中，返回值是void.</span>
     <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
     <span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// 返回指向第一个元素的迭代器，如要输出第一个值:*s.begin()</span>
<span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>  <span class="c1">// 返回一个指向当前set末尾元素的下一位置的迭代器</span>
<span class="n">s</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="c1">// 返回的值和end()相同</span>
<span class="n">s</span><span class="p">.</span><span class="n">rend</span><span class="p">()</span>  <span class="c1">// 返回的值和begin()相同</span>
<span class="n">s</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>  <span class="c1">// 清除所有元素</span>
<span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="c1">// 返回某个值元素的个数,因为不能重复，所以只有0/1,这样就成了判断元素是否存在了</span>
<span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="c1">// 如果集合为空，返回true</span>
<span class="n">s</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="c1">//返回一对pair类型的定位器,第一个表示&gt;=val,第二个表示&gt;val,有一个返回失败，就等于end()的值。</span>
     <span class="n">pair</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">,</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">pr</span><span class="p">;</span>
     <span class="n">pr</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
     <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;第一个大于等于 3 的数是 ：&quot;</span><span class="o">&lt;&lt;*</span><span class="n">pr</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
     <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;第一个大于 3的数是 ： &quot;</span><span class="o">&lt;&lt;*</span><span class="n">pr</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// set中的删除操作是不进行任何的错误检查的，比如定位器的是否合法等等，所以用的时候自己一定要注意。</span>
<span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>  <span class="c1">//删除定位器iterator指向的值</span>
<span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">second</span><span class="p">)</span><span class="c1">//删除定位器first和second之间的值</span>
<span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">key_value</span><span class="p">)</span><span class="c1">//删除键值key_value的值</span>
    <span class="c1">//第一种删除</span>
     <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
     <span class="c1">//第二种删除</span>
     <span class="n">first</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
     <span class="n">second</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
     <span class="n">second</span><span class="o">++</span><span class="p">;</span>
     <span class="n">second</span><span class="o">++</span><span class="p">;</span>
     <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">second</span><span class="p">);</span>
     <span class="c1">//第三种删除</span>

<span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="c1">//返回给定值值得迭代器，如果没找到则返回end()。</span>
<span class="n">s</span><span class="p">.</span><span class="n">get_allocator</span><span class="p">()</span><span class="c1">//–返回集合的分配器</span>
<span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">()</span><span class="c1">//–在集合中插入元素</span>
<span class="n">s</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">()</span><span class="c1">//–返回指向大于（或等于）某值的第一个元素的迭代器</span>
<span class="n">s</span><span class="p">.</span><span class="n">key_comp</span><span class="p">()</span><span class="c1">//–返回一个用于元素间值比较的函数 </span>
<span class="n">s</span><span class="p">.</span><span class="n">max_size</span><span class="p">()</span><span class="c1">//–返回集合能容纳的元素的最大限值</span>
<span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="c1">//–集合中元素的数目 </span>
<span class="n">s</span><span class="p">.</span><span class="n">swap</span><span class="p">()</span><span class="c1">//–交换两个集合变量</span>
<span class="n">s</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">key_value</span><span class="p">)</span> <span class="c1">// 返回第一个大于等于key_value的迭代器</span>
<span class="n">s</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">key_value</span><span class="p">)</span> <span class="c1">// 返回最后一个大于等于key_value的迭代器</span>
<span class="n">s</span><span class="p">.</span><span class="n">value_comp</span><span class="p">();</span><span class="c1">//–返回一个用于比较元素间的值的函数</span>
<span class="c1">// 遍历</span>
<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">){</span>
  <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_4">多线程<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>多线程是多任务处理的一种特殊形式，一般情况下，有基于进程和基于线程的两种类型的多任务处理方式。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
<li>使用时需要#include <thread>头文件，该头文件主要包含了对线程的管理类std::thread以及其他管理线程相关的类</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// 普通用法</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">output</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//创建一个线程t，第一个参数为调用的函数，第二个参数为传递的参数</span>
        <span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// 输出结果不一定是顺序输出</span>
        <span class="c1">//表示允许该线程在后台运行</span>
        <span class="n">t</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span> 
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 线程管理:每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个子线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以main函数作为入口函数的线程。</span>
<span class="c1">// 启动线程</span>
<span class="n">do_task</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">do_task</span><span class="p">);</span> <span class="c1">// std::thread的构造函数需要的是可调用（callable）类型，除了函数外，还可以调用例如：lambda表达式、重载了()运算符的类的实例。</span>
<span class="kr">thread</span> <span class="nf">t</span><span class="p">(</span><span class="n">output</span><span class="p">);</span><span class="c1">//假设有一个函数，且函数名为output，则此处可创建一个线程执行该函数</span>


<span class="c1">//当启动一个线程后，一定要在该线程thread销毁前，调用t.join()或者t.detach()，确定以何种方式等待线程执行结束</span>
<span class="o">*</span> <span class="n">detach方式</span><span class="err">，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。在以</span><span class="n">detach的方式执行线程时</span><span class="err">，要将线程访问的局部数据复制到线程的空间（使用按值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。</span>
<span class="o">*</span> <span class="n">join方式</span><span class="err">，等待关联的线程完成，才会继续执行</span><span class="n">join</span><span class="p">()</span><span class="err">后的代码。</span>


<span class="c1">// 异常情况下等待线程完成:为了避免主线程出现异常时将子线程终结，就要保证子线程在函数退出前完成，即在函数退出前调用join()。</span>
<span class="c1">// 方式一</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">thread</span> <span class="n">t</span><span class="p">([]{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;hello C++ 11&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">do_something_else</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(...)</span>
    <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// 方式二:资源获取即初始化（RAII）</span>
<span class="c1">// 无论是何种情况，当函数退出时，对象guard调用其析构函数销毁，从而能够保证join一定会被调用。</span>
<span class="k">class</span> <span class="nc">thread_guard</span>
<span class="p">{</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kr">thread</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="cm">/*加入explicit防止隐式转换，explicit仅可加在带一个参数的构造方法上，如：Demo test; test = 12.2;</span>
<span class="cm">        这样的调用就相当于把12.2隐式转换为Demo类型，加入explicit就禁止了这种转换。*/</span>
        <span class="k">explicit</span> <span class="n">thread_guard</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">_t</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_t</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">thread_guard</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
                <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">thread_guard</span><span class="p">(</span><span class="k">const</span> <span class="n">thread_guard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">//删除默认拷贝构造函数</span>
        <span class="n">thread_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">thread_guard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">//删除默认赋值运算符</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>

    <span class="kr">thread</span> <span class="n">t</span><span class="p">([]{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello thread&quot;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span> <span class="p">;</span>
    <span class="p">});</span>

    <span class="n">thread_guard</span> <span class="n">guard</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//线程互斥(std::mutex):通过mutex可以方便的对临界区域加锁，std::mutex类定义于mutex头文件，是用于保护共享数据避免从多个线程同时访问的同步原语，它提供了lock，try_lock，unlock等几个接口</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="n">do_something</span><span class="p">...;</span>    <span class="c1">//共享的数据</span>
<span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="c1">// mutex的lock和unlock必须成对调用，lock之后忘记调用unlock将是非常严重的错误，再次lock时会造成死锁。此时使用类模板std::lock_guard，通过RAII机制在其作用域内占有mutex，当程序流程离开创建lock_guard对象的作用域时，lock_guard对象被自动销毁并释放mutex。</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="n">do_something</span><span class="p">...;</span>    <span class="c1">//共享的数据</span>


<span class="c1">// 向线程传递参数：向线程调用的函数只需要在构造thread的实例时，依次传入即可。</span>


<span class="c1">// 转移线程的所有权.thread是可移动的(movable)的，但不可复制(copyable)。可以通过move来改变线程的所有权，灵活的决定线程在什么时候join或者detach。</span>
<span class="kr">thread</span> <span class="nf">t1</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
<span class="kr">thread</span> <span class="nf">t3</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">));</span>
<span class="c1">// 将线程从t1转移给t3,这时候t1就不再拥有线程的所有权，调用t1.join或t1.detach会出现异常，要使用t3来管理线程。这也就意味着thread可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程。</span>


<span class="c1">// 线程标识的获取:线程的标识类型为std::thread::id，有两种方式获得到线程的id</span>
<span class="o">*</span> <span class="err">通过</span><span class="n">thread的实例调用get_id</span><span class="p">()</span><span class="err">直接获取</span>
<span class="o">*</span> <span class="err">在当前线程上调用</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="err">获取</span>
</code></pre></div>
<h3 id="_5">文件和流<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p><img alt="image-20200212204453346" src="../assets/image-20200212204453346.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 这两个头文件必须写上</span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>


<span class="c1">// open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式</span>
<span class="kt">void</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">openmode</span> <span class="n">mode</span><span class="p">);</span>
<span class="o">*</span> <span class="n">ios</span><span class="o">::</span><span class="n">app</span><span class="o">--&gt;</span><span class="err">追加模式，所有写入都追加到文件末尾</span>
<span class="o">*</span> <span class="n">ios</span><span class="o">::</span><span class="n">ate</span><span class="o">--&gt;</span><span class="err">文件打开后定位到文件末尾</span>
<span class="o">*</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="o">--&gt;</span><span class="err">打开文件用于读取</span>
<span class="o">*</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="o">--&gt;</span><span class="err">打开文件用于写入</span>
<span class="o">*</span> <span class="n">ios</span><span class="o">::</span><span class="n">trunc</span><span class="o">--&gt;</span><span class="err">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设置为</span><span class="mi">0</span>
<span class="c1">//以写入模式打开文件，并希望截断文件，以防文件已存在</span>
<span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
<span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;file.dat&quot;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">trunc</span> <span class="p">);</span>
<span class="c1">//打开一个文件用于读写</span>
<span class="n">fstream</span>  <span class="n">afile</span><span class="p">;</span>
<span class="n">afile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;file.dat&quot;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="p">);</span>


<span class="c1">// 关闭文件:close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</span>
<span class="n">fstream</span>  <span class="n">afile</span><span class="p">;</span>
<span class="n">afile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;file.dat&quot;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="p">);</span>
<span class="n">afile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>


<span class="c1">// 写入与读取文件:使用流插入运算符（ &lt;&lt; ）向文件写入信息，使用流提取运算符（ &gt;&gt; ）从文件读取信息。</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
   <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
   <span class="c1">// 以写模式打开文件</span>
   <span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
   <span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;afile.dat&quot;</span><span class="p">);</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Writing to the file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Enter your name: &quot;</span><span class="p">;</span> 
   <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
   <span class="c1">// 向文件写入用户输入的数据</span>
   <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Enter your age: &quot;</span><span class="p">;</span> 
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
   <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">();</span>
   <span class="c1">// 再次向文件写入用户输入的数据</span>
   <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="c1">// 关闭打开的文件</span>
   <span class="n">outfile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

   <span class="c1">// 以读模式打开文件</span>
   <span class="n">ifstream</span> <span class="n">infile</span><span class="p">;</span> 
   <span class="n">infile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;afile.dat&quot;</span><span class="p">);</span> 
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Reading from the file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
   <span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span> 
   <span class="c1">// 在屏幕上写入数据</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

   <span class="c1">// 再次从文件读取数据，并显示它</span>
   <span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span> 
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

   <span class="c1">// 关闭打开的文件</span>
   <span class="n">infile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 文件位置指针</span>
<span class="c1">// istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（&quot;seek get&quot;）和关于 ostream 的 seekp（&quot;seek put&quot;）。</span>
<span class="c1">// seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</span>
<span class="c1">// 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。</span>

<span class="c1">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span>
<span class="n">fileObject</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span> <span class="n">n</span> <span class="p">);</span>

<span class="c1">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span>
<span class="n">fileObject</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">cur</span> <span class="p">);</span>

<span class="c1">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span>
<span class="n">fileObject</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">end</span> <span class="p">);</span>

<span class="c1">// 定位到 fileObject 的末尾</span>
<span class="n">fileObject</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">end</span> <span class="p">);</span>
</code></pre></div>
<h3 id="_6">日期和时间<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">//日期和时间，c++继承了c的日期和时间，#include&lt;ctime&gt;</span>
<span class="c1">//时间相关的类型：clock_t、time_t、size_t 和 tm</span>
<span class="c1">// 类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</span>
<span class="c1">// 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：</span>
<span class="k">struct</span> <span class="nc">tm</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">tm_sec</span><span class="p">;</span>   <span class="c1">// 秒，正常范围从 0 到 59，但允许至 61</span>
  <span class="kt">int</span> <span class="n">tm_min</span><span class="p">;</span>   <span class="c1">// 分，范围从 0 到 59</span>
  <span class="kt">int</span> <span class="n">tm_hour</span><span class="p">;</span>  <span class="c1">// 小时，范围从 0 到 23</span>
  <span class="kt">int</span> <span class="n">tm_mday</span><span class="p">;</span>  <span class="c1">// 一月中的第几天，范围从 1 到 31</span>
  <span class="kt">int</span> <span class="n">tm_mon</span><span class="p">;</span>   <span class="c1">// 月，范围从 0 到 11</span>
  <span class="kt">int</span> <span class="n">tm_year</span><span class="p">;</span>  <span class="c1">// 自 1900 年起的年数</span>
  <span class="kt">int</span> <span class="n">tm_wday</span><span class="p">;</span>  <span class="c1">// 一周中的第几天，范围从 0 到 6，从星期日算起</span>
  <span class="kt">int</span> <span class="n">tm_yday</span><span class="p">;</span>  <span class="c1">// 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</span>
  <span class="kt">int</span> <span class="n">tm_isdst</span><span class="p">;</span> <span class="c1">// 夏令时</span>
<span class="p">}</span>
<span class="c1">// 常用函数</span>
</code></pre></div>
<p><img alt="image-20200210205516351" src="../assets/image-20200210205516351.png" /></p>
<h3 id="opencv">opencv常用属性<a class="headerlink" href="#opencv" title="Permanent link">&para;</a></h3>
<p><strong>Mat常见类型</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 通用格式: CV_[每一项的位数][有符号或无符号][类型前缀]C[通道数]</span>
<span class="c1">// CV_8UC3:使用8位无符号的char类型，每个像素三通道(平面排列)</span>
   <span class="err">数据类型</span>       <span class="err">数值</span>     <span class="err">体类型</span>         <span class="err">取值范围</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;---</span><span class="n">CV_8U</span><span class="o">--</span><span class="mi">-8</span> <span class="err">位无符号整数</span><span class="o">--</span><span class="err">（</span><span class="mi">0</span><span class="err">…</span><span class="p">.</span><span class="mf">.255</span><span class="err">）</span>
<span class="n">Mat</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;-----</span><span class="n">CV_8S</span><span class="o">--</span><span class="mi">-8</span> <span class="err">位符号整数</span><span class="o">---</span><span class="err">（</span><span class="mi">-128</span><span class="err">…</span><span class="p">.</span><span class="mf">.127</span><span class="err">）</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="n">ushort</span><span class="o">&gt;--</span><span class="n">CV_16U</span><span class="o">-</span><span class="mi">-16</span> <span class="err">位无符号整数</span><span class="o">-</span><span class="err">（</span><span class="mi">0</span><span class="err">……</span><span class="mi">65535</span><span class="err">）</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;---</span><span class="n">CV_16S</span><span class="o">-</span><span class="mi">-16</span> <span class="err">位符号整数</span><span class="o">--</span><span class="err">（</span><span class="mi">-32768</span><span class="err">…</span><span class="p">.</span><span class="mf">.32767</span><span class="err">）</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;---</span><span class="n">CV_32F</span><span class="o">-</span><span class="mi">-32</span> <span class="err">位浮点数</span><span class="o">---</span><span class="err">（</span><span class="o">-</span><span class="n">FLT_MAX</span> <span class="err">………</span><span class="n">FLT_MAX</span><span class="err">，</span><span class="n">INF</span><span class="err">，</span><span class="n">NAN</span><span class="p">)</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;-----</span><span class="n">CV_32S</span><span class="o">-</span><span class="mi">-32</span> <span class="err">位符号整数</span><span class="o">--</span><span class="err">（</span><span class="mi">-2147483648</span><span class="err">……</span><span class="mi">2147483647</span><span class="err">）</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;--</span><span class="n">CV_64F</span><span class="o">-</span><span class="mi">-64</span> <span class="err">位浮点数</span><span class="o">---</span><span class="err">（</span><span class="o">-</span><span class="n">DBL_MAX</span> <span class="err">………</span><span class="p">.</span><span class="n">DBL_MAX</span><span class="err">，</span><span class="n">INF</span><span class="err">，</span><span class="n">NAN</span><span class="p">)</span>


<span class="c1">// Mat的构造函数</span>
<span class="n">Mat</span> <span class="p">()</span> <span class="c1">// 默认构造函数 Mat A;</span>
<span class="c1">// 常用构造函数 Mat A(10,10,CV_8UC3);</span>
<span class="n">Mat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="c1">//Mat(3,3,CV_8UC3，Scalar(127,0,255))</span>
<span class="n">Mat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
<span class="c1">//Mat src = imread(&quot;E:/OpenCV/OpenCVPicture/horse.png&quot;);</span>
<span class="c1">//Mat img= Mat(src.size(),CV_8UC1);      </span>
<span class="n">Mat</span> <span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="c1">// Mat(src.size(),CV_8UC3,Scalar(127,0,255));</span>
<span class="n">Mat</span> <span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
<span class="c1">// Mat copy_img(img);</span>
<span class="n">Mat</span> <span class="p">(</span><span class="k">const</span> <span class="n">Mat</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="c1">//Mat D (A, Rect(10, 10, 100, 100) ); // ROI截取，Rect(x,y,w,h);</span>
<span class="n">Mat</span> <span class="p">(</span><span class="k">const</span> <span class="n">Mat</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rect</span> <span class="o">&amp;</span><span class="n">roi</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="k">const</span> <span class="n">Mat</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">Range</span> <span class="o">*</span><span class="n">ranges</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sizes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sizes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">step</span><span class="o">=</span><span class="n">AUTO_STEP</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">step</span><span class="o">=</span><span class="n">AUTO_STEP</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ndims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sizes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">steps</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Mat</span> <span class="p">(</span><span class="k">const</span> <span class="n">Mat</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">Range</span> <span class="o">&amp;</span><span class="n">rowRange</span><span class="p">,</span> <span class="k">const</span> <span class="n">Range</span> <span class="o">&amp;</span><span class="n">colRange</span><span class="o">=</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">())</span>

<span class="n">Mat</span> <span class="n">d</span><span class="p">;</span>
<span class="n">d</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">xxx</span><span class="p">);</span><span class="c1">// xxx和上面一样</span>
<span class="c1">// Mat的常用赋值方法</span>
<span class="n">Mat</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">// 小矩阵直接用逗号隔开初始化</span>
<span class="n">Mat</span> <span class="n">R</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">CV_8UC3</span><span class="p">);</span>
<span class="n">randu</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">255</span><span class="p">));</span> <span class="c1">// 使用randu产生随机值来填充矩阵，需要给定一个上下限</span>
<span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">);</span><span class="c1">//  eye(int rows,int cols,int type)</span>
<span class="n">Mat</span><span class="o">::</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">CV_32F</span><span class="p">);</span> <span class="c1">// ones(int rows,int cols,int type)</span>
<span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">CV_8UC1</span><span class="p">);</span><span class="c1">// zeros(int rows,int cols,int type)</span>
<span class="c1">// 常用方法</span>
<span class="n">Mat</span> <span class="n">src</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">&quot;E:/OpenCV/OpenCVPicture/horse.png&quot;</span><span class="p">);</span> <span class="n">Mat</span> <span class="n">dst</span><span class="p">;</span>
<span class="n">src</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span> <span class="c1">// 将src对象的图像复制到dst对象中，深拷贝</span>
<span class="n">dst</span><span class="p">.</span><span class="n">clone</span><span class="p">(</span><span class="n">src</span><span class="p">);</span><span class="c1">// 将src对象的图像复制到dst对象中，深拷贝</span>
<span class="n">str</span><span class="p">.</span><span class="n">converto</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="n">CV_8UC3</span><span class="p">);</span> <span class="c1">// 将src转化成每个通道8个字节长度 uchar类型，通道数量为3的Mat对象（可以在函数后面附加因子进行计算）</span>
<span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span><span class="c1">// 通道数</span>
<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">depth</span><span class="p">();</span><span class="c1">// 图像深度</span>
<span class="n">src</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span><span class="c1">// bool 判断图像是否为空</span>
<span class="k">const</span> <span class="n">unchar</span><span class="o">*</span> <span class="n">firstRow</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">// 获取src图像的第一行对应指针</span>
<span class="c1">//  _Tp&amp; at(int row,int col) 获取图像上一个点的像素，可对其进行获取或者修改，灰度图像和RGB图像有区别</span>
<span class="n">Mat</span> <span class="n">gray_src</span><span class="p">;</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">gray_src</span><span class="p">,</span><span class="n">CV_BGR2GRAY</span><span class="p">);</span> <span class="c1">//将RGB图像转化成灰度图像</span>
<span class="n">uchar</span> <span class="n">test</span> <span class="o">=</span> <span class="n">gray_src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//获取灰度图像在 (0,0)处的像素值</span>
<span class="n">gray_src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">//修改灰度图像在 (0,0)处的像素值</span>

<span class="c1">//获取RGB像素</span>
<span class="n">uchar</span> <span class="n">blue</span><span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">//蓝色通道像素值</span>
<span class="n">uchar</span> <span class="n">green</span><span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">//绿色通道像素值</span>
<span class="n">uchar</span> <span class="n">red</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">//红色通道像素值</span>
<span class="c1">//修改RGB像素</span>
<span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//修改蓝色通道像素为0</span>
<span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//修改绿色通道像素为0</span>
<span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//修改红色通道像素为0</span>
</code></pre></div>
<p><strong>向量类Vec(一维，Matx的派生类)</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_cn</span><span class="o">&gt;</span><span class="c1">// 格式</span>
<span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">14</span><span class="p">);</span> <span class="c1">// 举例子</span>
<span class="c1">// 重命名</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2b</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3b</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4b</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2s</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3s</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4s</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2w</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3w</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4w</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">Vec8i</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6f</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6d</span><span class="p">;</span>
<span class="c1">// 常用属性</span>
<span class="n">vi</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span><span class="c1">// 向量的行数</span>
<span class="n">vi</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span><span class="c1">// 向量的列数</span>
<span class="n">vi</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">// 访问第0个元素</span>
<span class="c1">// 常用方法</span>
<span class="c1">/////////////////////// Vec (used as element of multi-channel images /////////////////////</span>

<span class="cm">/** @brief Template class for short numerical vectors, a partial case of Matx</span>

<span class="cm">This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you</span>
<span class="cm">can perform basic arithmetical operations, access individual elements using [] operator etc. The</span>
<span class="cm">vectors are allocated on stack, as opposite to std::valarray, std::vector, cv::Mat etc., which</span>
<span class="cm">elements are dynamically allocated in the heap.</span>

<span class="cm">The template takes 2 parameters:</span>
<span class="cm">@tparam _Tp element type</span>
<span class="cm">@tparam cn the number of elements</span>

<span class="cm">In addition to the universal notation like Vec&lt;float, 3&gt;, you can use shorter aliases</span>
<span class="cm">for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec&lt;float, 3&gt;.</span>

<span class="cm">It is possible to convert Vec\&lt;T,2\&gt; to/from Point_, Vec\&lt;T,3\&gt; to/from Point3_ , and Vec\&lt;T,4\&gt;</span>
<span class="cm">to CvScalar or Scalar_. Use operator[] to access the elements of Vec.</span>

<span class="cm">All the expected vector operations are also implemented:</span>
<span class="cm">-   v1 = v2 + v3</span>
<span class="cm">-   v1 = v2 - v3</span>
<span class="cm">-   v1 = v2 \* scale</span>
<span class="cm">-   v1 = scale \* v2</span>
<span class="cm">-   v1 = -v2</span>
<span class="cm">-   v1 += v2 and other augmenting operations</span>
<span class="cm">-   v1 == v2, v1 != v2</span>
<span class="cm">-   norm(v1) (euclidean norm)</span>
<span class="cm">The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.</span>
<span class="cm">*/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Vec</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">enum</span> <span class="p">{</span>
           <span class="n">channels</span> <span class="o">=</span> <span class="n">cn</span><span class="p">,</span>
<span class="cp">#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED</span>
           <span class="n">depth</span>    <span class="o">=</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">depth</span><span class="p">,</span>
           <span class="n">type</span>     <span class="o">=</span> <span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">channels</span><span class="p">),</span>
<span class="cp">#endif</span>
           <span class="n">_dummy_enum_finalizer</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="p">};</span>

    <span class="c1">//! default constructor</span>
    <span class="n">Vec</span><span class="p">();</span>

    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span> <span class="c1">//!&lt; 1-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">);</span> <span class="c1">//!&lt; 2-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">);</span> <span class="c1">//!&lt; 3-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">);</span> <span class="c1">//!&lt; 4-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">);</span> <span class="c1">//!&lt; 5-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">);</span> <span class="c1">//!&lt; 6-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">);</span> <span class="c1">//!&lt; 7-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">);</span> <span class="c1">//!&lt; 8-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v8</span><span class="p">);</span> <span class="c1">//!&lt; 9-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v8</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v9</span><span class="p">);</span> <span class="c1">//!&lt; 10-element vector constructor</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v8</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v9</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v10</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v11</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v12</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v13</span><span class="p">);</span> <span class="c1">//!&lt; 14-element vector constructor</span>
    <span class="k">explicit</span> <span class="nf">Vec</span><span class="p">(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span> <span class="n">values</span><span class="p">);</span>

<span class="cp">#ifdef CV_CXX11</span>
    <span class="n">Vec</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="n">Vec</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="k">static</span> <span class="n">Vec</span> <span class="n">all</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">alpha</span><span class="p">);</span>

    <span class="c1">//! per-element multiplication</span>
    <span class="n">Vec</span> <span class="nf">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conjugation (makes sense for complex numbers and quaternions)</span>
    <span class="n">Vec</span> <span class="nf">conj</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="cm">/*!</span>
<span class="cm">      cross product of the two 3D vectors.</span>

<span class="cm">      For other dimensionalities the exception is raised</span>
<span class="cm">    */</span>
    <span class="n">Vec</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">cn</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="cm">/*! element access */</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="nf">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

<span class="cp">#ifdef CV_CXX11</span>
    <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="n">Vec</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_AddOp</span><span class="p">);</span>
    <span class="n">Vec</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_SubOp</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_T2</span><span class="o">&gt;</span> <span class="n">Vec</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">_T2</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Matx_ScaleOp</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>Matx(轻量级Mat)</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">mat23f</span><span class="p">;</span><span class="c1">// 例子</span>
<span class="c1">// 重命名</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx12f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx12d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx13f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx13d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Matx14f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Matx14d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx16f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx16d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx21f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx21d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx31f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx31d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx41f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx41d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx61f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx61d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx22f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx22d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx23f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx23d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx32f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx32d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx33f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx33d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Matx34f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Matx34d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx43f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Matx43d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Matx44f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Matx44d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx66f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx66d</span><span class="p">;</span>
<span class="c1">// 常用方法</span>
<span class="cm">/** @brief Template class for small matrices whose type and size are known at compilation time</span>

<span class="cm">If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the</span>
<span class="cm">M(i,j) notation. Most of the common matrix operations (see also @ref MatrixExpressions ) are</span>
<span class="cm">available. To do an operation on Matx that is not implemented, you can easily convert the matrix to</span>
<span class="cm">Mat and backwards:</span>
<span class="cm">@code{.cpp}</span>
<span class="cm">    Matx33f m(1, 2, 3,</span>
<span class="cm">              4, 5, 6,</span>
<span class="cm">              7, 8, 9);</span>
<span class="cm">    cout &lt;&lt; sum(Mat(m*m.t())) &lt;&lt; endl;</span>
<span class="cm">@endcode</span>
<span class="cm">Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:</span>
<span class="cm">@code{.cpp}</span>
<span class="cm">    float values[] = { 1, 2, 3};</span>
<span class="cm">    Matx31f m(values);</span>
<span class="cm">@endcode</span>
<span class="cm">In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:</span>
<span class="cm">@code{.cpp}</span>
<span class="cm">    Matx31f m = { 1, 2, 3};</span>
<span class="cm">@endcode</span>
<span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Matx</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="p">{</span>
           <span class="n">rows</span>     <span class="o">=</span> <span class="n">m</span><span class="p">,</span>
           <span class="n">cols</span>     <span class="o">=</span> <span class="n">n</span><span class="p">,</span>
           <span class="n">channels</span> <span class="o">=</span> <span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span>
<span class="cp">#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED</span>
           <span class="n">depth</span>    <span class="o">=</span> <span class="n">traits</span><span class="o">::</span><span class="n">Type</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
           <span class="n">type</span>     <span class="o">=</span> <span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">channels</span><span class="p">),</span>
<span class="cp">#endif</span>
           <span class="n">shortdim</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">?</span> <span class="nl">m</span> <span class="p">:</span> <span class="n">n</span><span class="p">)</span>
         <span class="p">};</span>

    <span class="k">typedef</span> <span class="n">_Tp</span>                           <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span>               <span class="n">mat_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">shortdim</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">diag_type</span><span class="p">;</span>

    <span class="c1">//! default constructor</span>
    <span class="n">Matx</span><span class="p">();</span>

    <span class="k">explicit</span> <span class="nf">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span> <span class="c1">//!&lt; 1x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">);</span> <span class="c1">//!&lt; 1x2 or 2x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">);</span> <span class="c1">//!&lt; 1x3 or 3x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">);</span> <span class="c1">//!&lt; 1x4, 2x2 or 4x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">);</span> <span class="c1">//!&lt; 1x5 or 5x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">);</span> <span class="c1">//!&lt; 1x6, 2x3, 3x2 or 6x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">);</span> <span class="c1">//!&lt; 1x7 or 7x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">);</span> <span class="c1">//!&lt; 1x8, 2x4, 4x2 or 8x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v8</span><span class="p">);</span> <span class="c1">//!&lt; 1x9, 3x3 or 9x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v8</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v9</span><span class="p">);</span> <span class="c1">//!&lt; 1x10, 2x5 or 5x2 or 10x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v8</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v9</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v10</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v11</span><span class="p">);</span> <span class="c1">//!&lt; 1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v8</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v9</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v10</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v11</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v12</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v13</span><span class="p">);</span> <span class="c1">//!&lt; 1x14, 2x7, 7x2 or 14x1 matrix</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v4</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v5</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v6</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v7</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v8</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v9</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v10</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v11</span><span class="p">,</span>
         <span class="n">_Tp</span> <span class="n">v12</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v13</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v14</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v15</span><span class="p">);</span> <span class="c1">//!&lt; 1x16, 4x4 or 16x1 matrix</span>
    <span class="k">explicit</span> <span class="nf">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">*</span> <span class="n">vals</span><span class="p">);</span> <span class="c1">//!&lt; initialize from a plain array</span>

<span class="cp">#ifdef CV_CXX11</span>
    <span class="n">Matx</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">//!&lt; initialize from an initializer list</span>
<span class="cp">#endif</span>

    <span class="k">static</span> <span class="n">Matx</span> <span class="n">all</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">alpha</span><span class="p">);</span>
    <span class="k">static</span> <span class="n">Matx</span> <span class="n">zeros</span><span class="p">();</span>
    <span class="k">static</span> <span class="n">Matx</span> <span class="n">ones</span><span class="p">();</span>
    <span class="k">static</span> <span class="n">Matx</span> <span class="n">eye</span><span class="p">();</span>
    <span class="k">static</span> <span class="n">Matx</span> <span class="n">diag</span><span class="p">(</span><span class="k">const</span> <span class="n">diag_type</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">);</span>
    <span class="k">static</span> <span class="n">Matx</span> <span class="n">randu</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">a</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">b</span><span class="p">);</span>
    <span class="k">static</span> <span class="n">Matx</span> <span class="n">randn</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">a</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">b</span><span class="p">);</span>

    <span class="c1">//! dot product computed with the default precision</span>
    <span class="n">_Tp</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! dot product computed in double-precision arithmetics</span>
    <span class="kt">double</span> <span class="nf">ddot</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! change the matrix shape</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">m1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n1</span><span class="o">&gt;</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">n1</span><span class="o">&gt;</span> <span class="n">reshape</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! extract part of the matrix</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">m1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n1</span><span class="o">&gt;</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">n1</span><span class="o">&gt;</span> <span class="n">get_minor</span><span class="p">(</span><span class="kt">int</span> <span class="n">base_row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base_col</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! extract the matrix row</span>
    <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">row</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! extract the matrix column</span>
    <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">col</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! extract the matrix diagonal</span>
    <span class="n">diag_type</span> <span class="nf">diag</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! transpose the matrix</span>
    <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! invert the matrix</span>
    <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">&gt;</span> <span class="n">inv</span><span class="p">(</span><span class="kt">int</span> <span class="n">method</span><span class="o">=</span><span class="n">DECOMP_LU</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">p_is_ok</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! solve linear system</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">l</span><span class="o">&gt;</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="n">DECOMP_LU</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">method</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! multiply two matrices element-wise</span>
    <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! divide two matrices element-wise</span>
    <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;</span> <span class="n">div</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! element access</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="nf">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">);</span>

    <span class="c1">//! 1D element access</span>
    <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="nf">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

    <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_AddOp</span><span class="p">);</span>
    <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_SubOp</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_T2</span><span class="o">&gt;</span> <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">_T2</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Matx_ScaleOp</span><span class="p">);</span>
    <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_MulOp</span><span class="p">);</span>
    <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_DivOp</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">l</span><span class="o">&gt;</span> <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">Matx_MatMulOp</span><span class="p">);</span>
    <span class="n">Matx</span><span class="p">(</span><span class="k">const</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Matx_TOp</span><span class="p">);</span>

    <span class="n">_Tp</span> <span class="n">val</span><span class="p">[</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">];</span> <span class="c1">//&lt; matrix elements</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>Point常见类型</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/*二维点*/</span>
<span class="k">typedef</span> <span class="n">Point2i</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Point2i</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2I</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Point2f</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span>
<span class="cm">/*三维点*/</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3i</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3f</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3d</span>
<span class="c1">// 举例</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2f</span> <span class="n">p</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point3f</span> <span class="n">p</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="c1">// 常用方法</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Point_</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">//! default constructor</span>
    <span class="n">Point_</span><span class="p">();</span>
    <span class="n">Point_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="n">Point_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to the old-style C structures</span>
    <span class="k">operator</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! dot product</span>
    <span class="n">_Tp</span> <span class="nf">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! dot product computed in double-precision arithmetics</span>
    <span class="kt">double</span> <span class="nf">ddot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! cross-product</span>
    <span class="kt">double</span> <span class="nf">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! checks whether the point is inside the specified rectangle</span>
    <span class="kt">bool</span> <span class="nf">inside</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//!&lt; x coordinate of the point</span>
    <span class="n">_Tp</span> <span class="n">y</span><span class="p">;</span> <span class="c1">//!&lt; y coordinate of the point</span>
<span class="p">};</span>
</code></pre></div>
<p><strong>Scalar</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Scalar</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">);</span><span class="c1">// opencv中的颜色表示，表示具有 4个元素的数组，一般我们只用到前三个值</span>
<span class="c1">// 用法</span>
<span class="c1">//////////////////////////////// Scalar_ ///////////////////////////////</span>

<span class="cm">/** @brief Template class for a 4-element vector derived from Vec.</span>

<span class="cm">Being derived from Vec\&lt;_Tp, 4\&gt; , Scalar\_ and Scalar can be used just as typical 4-element</span>
<span class="cm">vectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in</span>
<span class="cm">OpenCV to pass pixel values.</span>
<span class="cm">*/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Scalar_</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//! default constructor</span>
    <span class="n">Scalar_</span><span class="p">();</span>   <span class="c1">//参数数量 0</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span><span class="c1">//参数数量2，3，4都可以</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span> <span class="c1">//参数数量 1</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cn</span><span class="o">&gt;</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="p">,</span> <span class="n">cn</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="c1">//! returns a scalar with all elements set to v0</span>
    <span class="k">static</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">all</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span>

    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! per-element product</span>
    <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! returns (v0, -v1, -v2, -v3)</span>
    <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">conj</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! returns true iff v1 == v2 == v3 == 0</span>
    <span class="kt">bool</span> <span class="nf">isReal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Scalar</span><span class="p">;</span>   <span class="c1">//double类型  scalar，方便声明定义用</span>
</code></pre></div>
<p><strong>Size</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Size2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span> <span class="n">Size2l</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Size2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Size2d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size2i</span> <span class="n">Size</span><span class="p">;</span>
<span class="c1">// 用法</span>
<span class="c1">//////////////////////////////// Size_ ////////////////////////////////</span>

<span class="cm">/** @brief Template class for specifying the size of an image or rectangle.</span>

<span class="cm">The class includes two members called width and height. The structure can be converted to and from</span>
<span class="cm">the old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison</span>
<span class="cm">operations as for Point_ is available.</span>

<span class="cm">OpenCV defines the following Size_\&lt;\&gt; aliases:</span>
<span class="cm">@code</span>
<span class="cm">    typedef Size_&lt;int&gt; Size2i;</span>
<span class="cm">    typedef Size2i Size;</span>
<span class="cm">    typedef Size_&lt;float&gt; Size2f;</span>
<span class="cm">@endcode</span>
<span class="cm">*/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Size_</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">//! default constructor</span>
    <span class="n">Size_</span><span class="p">();</span>       <span class="c1">//默认构造函数</span>
    <span class="n">Size_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_height</span><span class="p">);</span>   <span class="c1">//宽 高</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>  <span class="c1">//拷贝构造函数</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">);</span>  <span class="c1">//转换构造函数</span>

    <span class="n">Size_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="c1">//! the area (width*height)</span>
    <span class="n">_Tp</span> <span class="nf">area</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! true if empty</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion of another data type.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">width</span><span class="p">;</span> <span class="c1">//!&lt; the width</span>
    <span class="n">_Tp</span> <span class="n">height</span><span class="p">;</span> <span class="c1">//!&lt; the height</span>
<span class="p">};</span>
<span class="c1">// 属性</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Size</span> <span class="n">size</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="n">size</span><span class="p">.</span><span class="n">area</span><span class="p">();</span><span class="c1">// 矩形面积</span>
<span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
<span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</code></pre></div>
<p><strong>Rect</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Rect2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Rect2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Rect2d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Rect2i</span> <span class="n">Rect</span><span class="p">;</span>
<span class="c1">// 常用属性和方法</span>
<span class="n">rect</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">rect</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="c1">// 表示左上角坐标</span>
<span class="n">rect</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="n">rect</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="c1">// 表示宽高</span>
<span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">// 返回Rect对象的尺寸</span>
<span class="n">rect</span><span class="p">.</span><span class="n">area</span><span class="p">();</span><span class="c1">// 返回Rect对象的面积大小</span>
<span class="n">rect</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span><span class="c1">// 检测点pt是否在Rect对象内；</span>
<span class="n">rect</span><span class="p">.</span><span class="n">tl</span><span class="p">();</span><span class="c1">// 左上角坐标</span>
<span class="n">rect</span><span class="p">.</span><span class="n">br</span><span class="p">();</span><span class="c1">// 右下角坐标</span>
<span class="kt">bool</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point_</span><span class="o">&lt;</span> <span class="n">_Tp</span> <span class="o">&gt;::</span><span class="n">inside</span>  <span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span> <span class="n">_Tp</span> <span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// 判断一个点是否在矩形对象内</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">rect1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">rect1</span> <span class="o">&amp;</span> <span class="n">rect2</span><span class="p">;</span> <span class="c1">//交集</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">rect1</span> <span class="o">|</span> <span class="n">rect2</span><span class="p">;</span> <span class="c1">//并集</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">rect1</span> <span class="o">+</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">//平移</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rect</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">rect1</span> <span class="o">+</span> <span class="n">Size</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>    <span class="c1">//矩形框加大</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;矩形r1：%d %d %d %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">r1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">r1</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="n">r1</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;矩形r2：%d %d %d %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">r2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">r2</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">r2</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;矩形r3：%d %d %d %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">r3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">r3</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">r3</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;矩形r4：%d %d %d %d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">r4</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">r4</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">r4</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">r4</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</code></pre></div>
<p><strong>OpenCV中的新增数学函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">CV_EXPORTS_W</span> <span class="kt">float</span> <span class="n">cubeRoot</span><span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// 计算立方根</span>
<span class="n">CV_EXPORTS_W</span> <span class="kt">float</span> <span class="n">fastAtan2</span><span class="p">(</span><span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">);</span><span class="c1">// 计算向量角度计算</span>
<span class="c1">// #include &lt;opencv2/core/fast_math.hpp&gt;</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvRound</span><span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span>   <span class="c1">//四舍五入函数</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvFloor</span><span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span>  <span class="c1">//向下取整</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvCeil</span><span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span>    <span class="c1">//向上取整</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvIsNaN</span><span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span>   <span class="c1">//判断是否是一个数</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvIsInf</span><span class="p">(</span> <span class="kt">double</span> <span class="n">value</span> <span class="p">)</span>   <span class="c1">//判断是否无穷大</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvRound</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvRound</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvFloor</span><span class="p">(</span> <span class="kt">float</span> <span class="n">value</span> <span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvFloor</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvCeil</span><span class="p">(</span> <span class="kt">float</span> <span class="n">value</span> <span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvCeil</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvIsNaN</span><span class="p">(</span> <span class="kt">float</span> <span class="n">value</span> <span class="p">)</span>
<span class="n">CV_INLINE</span> <span class="kt">int</span> <span class="n">cvIsInf</span><span class="p">(</span> <span class="kt">float</span> <span class="n">value</span> <span class="p">)</span>
</code></pre></div>
<p><strong>其他类型</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 颜色空间转化</span>
<span class="n">C</span><span class="o">++</span><span class="err">：</span><span class="kt">void</span> <span class="n">cvtColor</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstCn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">*</span> <span class="n">InputArray</span> <span class="n">src</span><span class="err">：表示输入图像；</span>
<span class="o">*</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="err">：表示输出图像；</span>
<span class="o">*</span> <span class="kt">int</span> <span class="n">code</span><span class="err">：表示颜色空间转换标识符；</span>
<span class="o">*</span> <span class="kt">int</span> <span class="n">dstCn</span> <span class="o">=</span> <span class="mi">0</span><span class="err">：目标图像的通道数；</span><span class="mi">0</span><span class="err">：目标图像取源图像的通道数；</span>
<span class="c1">// 例子</span>
<span class="cm">/*OpenCv2 版本*/</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">srcImage</span><span class="p">,</span> <span class="n">dstImage</span><span class="p">,</span> <span class="n">CV_GRAY2BGR</span><span class="p">);</span>
<span class="cm">/*OpenCv3 版本*/</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">srcImage</span><span class="p">,</span> <span class="n">dstImage</span><span class="p">,</span> <span class="n">COLOR_GRAY2BGR</span><span class="p">);</span>
<span class="c1">// code</span>
<span class="n">RGB</span><span class="o">&lt;-&gt;</span><span class="nl">BGR</span><span class="p">:</span><span class="n">COLOR_BGR2BGRA</span><span class="err">、</span><span class="n">COLOR_RGB2RGBA</span><span class="err">、</span><span class="n">COLOR_BGRA2RGBA</span><span class="err">、</span><span class="n">COLOR_BGR2BGRA</span><span class="err">、</span><span class="n">COLOR_BGRA2BGR</span>
<span class="n">RGB</span><span class="o">&lt;-&gt;</span><span class="nl">Gray</span><span class="p">:</span><span class="n">COLOR_RGB2GRAY</span><span class="err">、</span><span class="n">COLOR_GRAY2RGB</span><span class="err">、</span><span class="n">COLOR_RGBA2GRAY</span><span class="err">、</span><span class="n">COLOR_GRAY2RGBA</span>
<span class="n">RGB</span><span class="o">&lt;-&gt;</span><span class="nl">HSV</span><span class="p">:</span><span class="n">COLOR_BGR2HSV</span><span class="err">、</span><span class="n">COLOR_RGB2HSV</span><span class="err">、</span><span class="n">COLOR_HSV2BGR</span><span class="err">、</span><span class="n">COLOR_HSV2RGB</span>
<span class="n">RGB</span><span class="o">&lt;-&gt;</span><span class="nl">HLS</span><span class="p">:</span><span class="n">COLOR_BGR2HSV</span><span class="err">、</span><span class="n">COLOR_RGB2HSV</span><span class="err">、</span><span class="n">COLOR_HSV2BGR</span><span class="err">、</span><span class="n">COLOR_HSV2RGB</span>
<span class="c1">// 特殊使用：当需要把一个 88 位的 RGB 图像转化为 Luv 格式的图像时，需要先把图像转化为单精度 3232 位</span>
<span class="n">img</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="mi">255</span><span class="p">;</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">COLOR_BGR2Luv</span><span class="p">);</span>
</code></pre></div>
<p><strong>图像/视频操作函数</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 1.imread:OpenCV支持bmp、jpg、png、tiff等常用图像格式的解析</span>
<span class="n">Mat</span> <span class="nf">imread</span><span class="p">(</span> <span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">IMREAD_COLOR</span> <span class="p">);</span>
<span class="o">*</span> <span class="n">IMREAD_UNCHANGED</span><span class="err">：不对图像文件进行任何转换，直接读取；</span>
<span class="o">*</span> <span class="n">IMREAD_GRAYSCALE</span><span class="err">：将任何图像均转换为灰度图像</span><span class="p">(</span><span class="err">单通道</span><span class="p">)</span><span class="err">进行读取；</span>
<span class="o">*</span> <span class="n">IMREAD_COLOR</span><span class="err">：将任何图像均转为</span><span class="n">RGB彩色图像</span><span class="p">(</span><span class="err">三通道</span><span class="p">)</span><span class="err">进行读取；</span>
<span class="o">*</span> <span class="n">IMREAD_ANYDEPTH</span><span class="err">：如果不设置这个参数，</span><span class="mi">16</span><span class="o">/</span><span class="mi">32</span><span class="err">位图像将会自动转为</span><span class="mi">8</span><span class="err">位图像；</span>
<span class="o">*</span> <span class="n">IMREAD_ANYCOLOR</span><span class="err">：将按照图像文件设定的颜色格式进行图像读取；</span>
<span class="o">*</span> <span class="n">IMREAD_LOAD_GDAL</span><span class="err">：调用</span><span class="n">gdal库进行图像文件读取</span><span class="p">(</span><span class="err">可以简单地理解为读取</span><span class="n">TIFF图像文件</span><span class="p">)</span><span class="err">。</span>
<span class="c1">// 例子</span>
<span class="n">Mat</span> <span class="n">image</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="err">&#39;</span><span class="n">test</span><span class="p">.</span><span class="n">jpg</span><span class="err">&#39;</span><span class="p">,</span><span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_GRAYSCALE</span><span class="p">);</span>
<span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span><span class="c1">// 宽度</span>
<span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span><span class="c1">// 高度</span>
<span class="n">image</span><span class="p">.</span><span class="n">channels</span><span class="p">();</span><span class="c1">// 通道数</span>
<span class="n">image</span><span class="p">.</span><span class="n">elemSize</span><span class="p">();</span><span class="c1">// 一个像素占用的字节数</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">image</span><span class="p">.</span><span class="n">elemSize</span><span class="p">()</span><span class="o">/</span><span class="n">image</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span> <span class="o">*</span> <span class="mi">8</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">//2.imshow() 只支持8位灰度图像、8位彩色图像和32位灰度图像(像素值范围0-1)</span>
<span class="kt">void</span> <span class="nf">imshow</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="n">winname</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">mat</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">();</span>

<span class="c1">// 3.imwrite() 只支持单通道和3通道的图像，并且此时要求其深度为8bit和16bit无符号,其他一些数据类型是不支持的，比如说float型等。如果Mat类型数据的深度和通道数不满足上面的要求，则需要使用convertTo()函数和cvtColor()函数来进行转换</span>
<span class="kt">bool</span> <span class="nf">imwrite</span><span class="p">(</span> <span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">img</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">params</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

<span class="c1">// 4.图像遍历</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="o">&gt;</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">);</span>
<span class="o">*</span>　<span class="err">单通道灰度</span> <span class="kt">unsigned</span> <span class="kt">char</span>
<span class="o">*</span>　<span class="err">三通道彩色</span><span class="p">(</span><span class="mi">8</span><span class="err">位</span><span class="p">)</span> <span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span>
<span class="o">*</span>　<span class="mi">16</span><span class="err">位灰度</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="o">*</span>　<span class="mi">32</span><span class="err">位浮点型</span>    <span class="kt">float</span>
<span class="o">*</span>　<span class="err">双通道</span><span class="mi">32</span><span class="err">位</span>    <span class="n">cv</span><span class="o">::</span><span class="n">Vec2f</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//数据缓存区指针 使用data属性获取数据缓存区指针，利用指针直接读取数据缓存区的内容。例如</span>
<span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">&quot;test.png&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_GRAYSCALE</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">img_data</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">img_data</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="o">++</span><span class="n">img_data</span><span class="p">;</span> <span class="c1">// 指针增加</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//　行首指针，ptr接口来直接获取每一行的行首指针</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="s">&quot;test.png&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_GRAYSCALE</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">rdata</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">rdata</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="o">++</span><span class="n">rdata</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 5.视频操作函数</span>
<span class="c1">//功能：创建一个VideoCapture类的实例，如果传入对应的参数，可以直接打开视频文件或者要调用的摄像头。</span>
<span class="c1">//参数: filename – 打开的视频文件名。</span>
<span class="c1">//device – 打开的视频捕获设备id ，如果只有一个摄像头可以填0，表示打开默认的摄像头。</span>
<span class="n">VideoCapture</span><span class="o">::</span><span class="n">VideoCapture</span><span class="p">();</span>  
<span class="n">VideoCapture</span><span class="o">::</span><span class="n">VideoCapture</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>  
<span class="n">VideoCapture</span><span class="o">::</span><span class="n">VideoCapture</span><span class="p">(</span><span class="kt">int</span> <span class="n">device</span><span class="p">);</span>  

<span class="c1">//功能：打开一个视频文件或者打开一个捕获视频的设备(也就是摄像头)</span>
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>  
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="kt">int</span> <span class="n">device</span><span class="p">);</span>

<span class="c1">//功能：判断视频读取或者摄像头调用是否成功，成功则返回true</span>
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">isOpened</span><span class="p">();</span>

<span class="c1">//功能：关闭视频文件或者摄像头</span>
<span class="kt">void</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">release</span><span class="p">();</span>

<span class="c1">//功能：读取视频内容</span>
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">grab</span><span class="p">();</span>  <span class="c1">//若没有视频帧被捕获，返回false</span>
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">retrieve</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">//若没有视频帧被捕获，返回false</span>
<span class="n">VideoCapture</span><span class="o">&amp;</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">);</span>  <span class="c1">//若没有视频帧被捕获，返回空，即cv::Mat.empty()返回true</span>
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">);</span>  <span class="c1">//若没有视频帧被捕获，返回false</span>

<span class="c1">//功能：获得视频有诸多属性，比如：帧率、总帧数、尺寸、格式等</span>
<span class="c1">//如果查询的视频属性是VideoCapture类不支持的，将会返回0</span>
<span class="kt">double</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">propId</span><span class="p">);</span>  

<span class="c1">//功能：设置VideoCapture类的属性，设置成功返回ture,失败返回false</span>
<span class="c1">//参数：第一个是属性ID，第二个是该属性要设置的值</span>
<span class="kt">bool</span> <span class="n">VideoCapture</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">propertyId</span><span class="p">,</span> <span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
<span class="c1">// 视频属性介绍</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_POS_MSEC</span>  <span class="err">以毫秒计算的当前的位置</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_POS_FRAMES</span>    <span class="err">以帧计算当前的位置</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_POS_AVI_RATIO</span> <span class="err">视频的相对位置，</span><span class="mi">0</span><span class="err">表示视频开始，</span><span class="mi">1</span><span class="err">表示视频结束</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_FRAME_WIDTH</span>   <span class="err">帧宽度</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_FRAME_HEIGHT</span>  <span class="err">帧高度</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_FPS</span>   <span class="err">帧率</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_FOURCC</span>    <span class="mi">4</span><span class="err">字符编码方式</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_FRAME_COUNT</span>   <span class="err">视频帧数</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_FORMAT</span>    <span class="err">视频格式</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_MODE</span>  
<span class="o">*</span> <span class="n">CV_CAP_PROP_BRIGHTNESS</span>    <span class="err">亮度</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_CONTRAST</span>  <span class="err">对比度</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_SATURATION</span>    <span class="err">饱和度</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_HUE</span>   <span class="err">色调</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_GAIN</span>  <span class="err">增益</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_EXPOSURE</span>  <span class="err">曝光</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_CONVERT_RGB</span>   <span class="err">图像是否应转换为</span><span class="n">RGB的标志</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_WHITE_BALANCE</span> <span class="err">白平衡</span>
<span class="o">*</span> <span class="n">CV_CAP_PROP_RECTIFICATION</span> 

<span class="c1">// 视频保存函数，filename参数表示文件名，fourcc参数表示编码格式，fps参数表示视频帧率，frameSize表示视频的尺寸大小</span>
<span class="n">VideoWriter</span><span class="o">::</span><span class="n">VideoWriter</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fourcc</span><span class="p">,</span>
                         <span class="kt">double</span> <span class="n">fps</span><span class="p">,</span> <span class="n">Size</span> <span class="n">frameSize</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isColor</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">VideoWriter</span><span class="o">::</span><span class="n">open</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fourcc</span><span class="p">,</span>
                       <span class="kt">double</span> <span class="n">fps</span><span class="p">,</span> <span class="n">Size</span> <span class="n">frameSize</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isColor</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>
<span class="c1">// 常见编码格式，OpenCV里对视频的编码解码等支持并不是很良好，所以不要希望用这个类去实现摄像头图像的获取与转码，有兴趣的可以参考FFmpeg库。</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;P&#39;</span><span class="p">,</span><span class="sc">&#39;I&#39;</span><span class="p">,</span><span class="sc">&#39;M&#39;</span><span class="p">,</span><span class="sc">&#39;1&#39;</span><span class="p">)</span>    <span class="n">MPEG</span><span class="mi">-1</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">,</span><span class="sc">&#39;J&#39;</span><span class="p">,</span><span class="sc">&#39;P&#39;</span><span class="p">,</span><span class="sc">&#39;G&#39;</span><span class="p">)</span>    <span class="n">motion</span><span class="o">-</span><span class="n">jpeg</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="sc">&#39;P&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">)</span> <span class="n">MPEG</span><span class="mf">-4.2</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="sc">&#39;V&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span> <span class="n">MPEG</span><span class="mf">-4.3</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="sc">&#39;V&#39;</span><span class="p">,</span> <span class="sc">&#39;X&#39;</span><span class="p">)</span> <span class="n">MPEG</span><span class="mi">-4</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;U&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span> <span class="n">H263</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;I&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">)</span> <span class="n">H263I</span>
<span class="o">*</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;F&#39;</span><span class="p">,</span> <span class="sc">&#39;L&#39;</span><span class="p">,</span> <span class="sc">&#39;V&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="n">FLV1</span>
</code></pre></div>
<p><strong>视频读取</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">VideoCapture</span> <span class="n">cap</span><span class="p">;</span>
    <span class="n">cap</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;test.mp4&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">())</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FRAME_WIDTH</span><span class="p">);</span>             <span class="c1">//帧宽度</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FRAME_HEIGHT</span><span class="p">);</span>           <span class="c1">//帧高度</span>
    <span class="kt">int</span> <span class="n">totalFrames</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FRAME_COUNT</span><span class="p">);</span>       <span class="c1">//总帧数</span>
    <span class="kt">int</span> <span class="n">frameRate</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FPS</span><span class="p">);</span>                 <span class="c1">//帧率 x frames/s</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;视频宽度： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">width</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;视频高度： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;视频总帧数： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">totalFrames</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;帧率： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">frameRate</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">frame</span><span class="p">;</span>
    <span class="c1">// cap.set(CV_CAP_PROP_POS_FRAMES, 20);        //跳转到第20帧</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cap</span> <span class="o">&gt;&gt;</span> <span class="n">frame</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cap</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>视频存储</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">VideoCapture</span> <span class="n">cap</span><span class="p">;</span>
    <span class="n">cap</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;test.mp4&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">())</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FRAME_WIDTH</span><span class="p">);</span>             <span class="c1">//帧宽度</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FRAME_HEIGHT</span><span class="p">);</span>           <span class="c1">//帧高度</span>
    <span class="kt">int</span> <span class="n">totalFrames</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FRAME_COUNT</span><span class="p">);</span>       <span class="c1">//总帧数</span>
    <span class="kt">int</span> <span class="n">frameRate</span> <span class="o">=</span> <span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">CV_CAP_PROP_FPS</span><span class="p">);</span>                 <span class="c1">//帧率 x frames/s</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;视频宽度： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">width</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;视频高度： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">height</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;视频总帧数： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">totalFrames</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;帧率： &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">frameRate</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">VideoWriter</span> <span class="n">wri</span><span class="p">;</span>
    <span class="n">wri</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;test_copy.avi&quot;</span><span class="p">,</span> <span class="n">CV_FOURCC</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">,</span> <span class="sc">&#39;P&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">),</span> <span class="n">frameRate</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">));</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">frame</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cap</span> <span class="o">&gt;&gt;</span> <span class="n">frame</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">wri</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cap</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
    <span class="n">wri</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E5%BA%93%28albumentations%2BAugmentor%29/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              图像增强库
            </div>
          </div>
        </a>
      
      
        <a href="../vim_cmake_git/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              vim_git_cmake
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../assets/javascripts/workers/search.fb4a9340.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.ca5457b8.min.js"></script>
      
    
  </body>
</html>